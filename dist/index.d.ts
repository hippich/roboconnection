// Generated by dts-bundle v0.7.3
// Dependencies for this module:
/// <reference path="../events" />

declare module 'roboconnection' {
    import { JiboConnection, ConnectionInfo, RobotInfo } from 'roboconnection/connection/RobotConnection';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    export { JiboConnection, ConnectionInfo, RobotInfo, Requester };
}

declare module 'roboconnection/connection/RobotConnection' {
    import { EventEmitter } from "events";
    export interface ConnectionInfo {
        clientId: string;
        clientSecret: string;
        port: number;
    }
    export interface RobotInfo {
        name: string;
        serialName: string;
        endpoint: string;
        email: string;
        password: string;
        ip: string;
        onConnected: any;
        onDisconnected: any;
    }
    export class JiboConnection extends EventEmitter {
        static MAX_TRIES: number;
        static DEFAULT_PORT: number;
        static DEV_ENDPOINT: string;
        static STG_ENDPOINT: string;
        static PREPROD_ENDPOINT: string;
        static PROD_ENDPOINT: string;
        static ENVIRONMENT_OPTIONS: any;
        constructor(robotInfo: RobotInfo, connectionInfo: ConnectionInfo);
        connect(debugLogging?: boolean): void;
        login(): void;
        getRobotList(): void;
        createCertificate(): void;
        retrieveCertificate(): void;
        connectToRobot(ipAddress: string, key: string, cert: string, fingerprint: string, callback: any): void;
        disconnect(): void;
        readonly connected: boolean;
        statusMessage(message: string, clearMessages?: boolean): void;
        logDebug(...args: any[]): void;
        logError(...args: any[]): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/Requester' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import { v1 } from 'roboconnection/connection/jibo-command-requester/requests';
    import Attention = v1.expression.attention.Attention;
    import LookAt = v1.expression.lookAt.LookAt;
    import Display = v1.expression.display.Display;
    import VideoPlayback = v1.expression.video.VideoPlayback;
    import FaceTrack = v1.lps.face.FaceTrack;
    import MotionTrack = v1.lps.motion.MotionTrack;
    import HotWord = v1.listen.hotWord.HotWord;
    import Listen = v1.listen.listen.Listen;
    import Play = v1.expression.play.Play;
    import Photo = v1.camera.photo.Photo;
    import Video = v1.camera.video.Video;
    import LoadAssets = v1.loadAssets.LoadAssets;
    import UnloadAssets = v1.unloadAssets.UnloadAssets;
    import HeadTouch = v1.sensory.headTouch.HeadTouch;
    import GetConfig = v1.settings.getConfig.GetConfig;
    import SetConfig = v1.settings.setConfig.SetConfig;
    import ScreenGesture = v1.sensory.screenGesture.ScreenGesture;
    import { Event } from 'roboconnection/connection/jibo-command-requester/events/Event';
    /**
        * Entry point for the Remote Client Protocol.
        * @class Requester
        * @example
        * const requester = new Requester();
        * requester.disconnected.on((data) => {
        *     console.log('Connection closed because', data);
        * });
        * await requester.connect(robotName);
        */
    export default class Requester {
            /**
                * @name Requester#attention
                * @description Instance property on the Requester class. See {@link Requester.attention} namespace.
                */
            attention: Attention;
            /**
                * @name Requester#lookAt
                * @description Instance property on the Requester class. See {@link Requester.lookAt} namespace.
                */
            lookAt: LookAt;
            /**
                * @name Requester#display
                * @description Instance property on the Requester class. See {@link Requester.display} namespace.
                */
            display: Display;
            /**
                * @name Requester#display
                * @description Instance property on the Requester class. See {@link Requester.videoPlayback} namespace.
                */
            videoPlayback: VideoPlayback;
            /**
                * @name Requester#faceTrack
                * @description Instance property on the Requester class. See {@link Requester.faceTrack} namespace.
                */
            faceTrack: FaceTrack;
            /**
                * @name Requester#motionTrack
                * @description Instance property on the Requester class. See {@link Requester.motionTrack} namespace.
                */
            motionTrack: MotionTrack;
            /**
                * @name Requester#play
                * @description Instance property on the Requester class. See {@link Requester.play} namespace.
                */
            play: Play;
            /**
                * @name Requester#photo
                * @description Instance property on the Requester class. See {@link Requester.photo} namespace.
                */
            photo: Photo;
            /**
                * @name Requester#video
                * @description Instance property on the Requester class. See {@link Requester.video} namespace.
                */
            video: Video;
            /**
                * @name Requester#listen
                * @description Instance property on the Requster class. See {@link Requester.listen} namespace.
                */
            listen: Listen;
            /**
                * @name Requester#hotWord
                * @description Instance property on the Requester class. See {@link Requester.hotWord} namespace.
                */
            hotWord: HotWord;
            /**
                * @name Requester#loadAssets
                * @description Instance property on the Requester class. See {@link Requester.loadAssets} namespace.
                */
            loadAssets: LoadAssets;
            /**
                * @name Requester#unloadAssets
                * @description Instance property on the Requester class. See {@link Requester.unloadAssets} namespace.
                */
            unloadAssets: UnloadAssets;
            /**
                * @name Requester#headTouch
                * @description Instance property on the Requester class. See {@link Requester.headTouch} namespace.
                */
            headTouch: HeadTouch;
            /**
                * @name Requester#getConfig
                * @description Instance property on the Requester class. See {@link Requester.getConfig} namespace.
                */
            getConfig: GetConfig;
            /**
                * @name Requester#setConfig
                * @description Instance property on the Requester class. See {@link Requester.setConfig} namespace.
                */
            setConfig: SetConfig;
            /**
                * @name Requester#screenGesture
                * @description Instance property on the Requester class. See {@link Requester.screenGesture} namespace.
                */
            screenGesture: ScreenGesture;
            /**
                * ID for the app.
                * @name Requester#AppID
                * @type string
                */
            AppID: string;
            /**
                * Event emitted when the connection is closed by the robot or a connection issue.
                * @name Requester#disconnected
                * @type Event<number, string>
                */
            disconnected: Event<{
                    code: number;
                    reason: string;
            }>;
            expression: any;
            config: any;
            perception: any;
            constructor();
            /**
                * Connect to the specific robot.
                * @method Requester#connect
                * @param  {string}        robotName your-friendly-robot-name
                * @return {Promise<void>}
                */
            connect(robotName: string, options: any): Promise<void>;
            /**
                * Disconnect all active connections.
                * @method Requester.disconnect
                */
            disconnect(): void;
            /**
                * @private
                */
            sendRequest(command: JIBO.v1.BaseCommand): string;
            /**
                * @private
                */
            sendToken(token: RequestToken<any>): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/tokens/RequestToken' {
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import ExternalPromise from 'roboconnection/connection/jibo-command-requester/utils/ExternalPromise';
    /**
        * Every request has a token with a completion promise and any events relative to that command.
        * @class RequestToken
        */
    export default abstract class RequestToken<C extends JIBO.v1.BaseCommand, Result = any> {
            /**
                * Protocol data to be sent along the websocket.
                * @private
                */
            protocol: C;
            /**
                * Unique id for this request, and any responses to it.
                * @private
                */
            requestId: string;
            /**
                * Internal flag for the Requester to know that it no longer needs to track the token. Must
                * be updated by subclasses when `complete` resolves.
                * @private
                */
            isComplete: boolean;
            /**
                * For subclasses to know where to send cancel requests
                * @private
                */
            owner: Requester;
            protected _complete: ExternalPromise<Result>;
            /**
                * Request completion promise.
                * @method RequestToken#complete
                * @returns this
                */
            readonly complete: Promise<Result>;
            /** @private */
            constructor(owner: Requester, protocol: C);
            /**
                * Cancel the request.
                * @method RequestToken#cancel
                */
            cancel(): void;
            /**
                * Internal listener method for handling responses
                * @private
                */
            abstract handleAck(data: JIBO.v1.Acknowledgement): void;
            /**
                * Internal listener method for handling responses
                * @private
                */
            abstract handleEvent(data: JIBO.v1.EventMessage): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests' {
    import * as v1 from 'roboconnection/connection/jibo-command-requester/requests/v1';
    import * as v2 from 'roboconnection/connection/jibo-command-requester/requests/v2';
    export { v1, v2 };
}

declare module 'roboconnection/connection/jibo-command-requester/events/Event' {
    export interface Handler<Type> {
        (data?: Type): void;
    }
    export enum EmitterMode {
        ALL_HANDLERS = "ALL_HANDLERS",
        FIRST_HANDLER = "FIRST_HANDLER",
        LAST_HANDLER = "LAST_HANDLER"
    }
    export class Event<Type> {
        name: string;
        constructor(name: string);
        listeners(): Handler<Type>[];
        setMaxListeners(n: number): this;
        getMaxListeners(): number;
        once(handler: Handler<Type>): this;
        on(handler: Handler<Type>): this;
        removeLastListener(): void;
        removeFirstListener(): void;
        addListener(handler: Handler<Type>): this;
        removeListener(handler: Handler<Type>): this;
        off(handler: Handler<Type>): this;
        removeAllListeners(): this;
        emit(data?: Type): boolean;
        setMode(mode: EmitterMode): void;
        waitFor(timeoutMs?: number): Promise<Type>;
        listenerCount(): number;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/utils/ExternalPromise' {
    export default class ExternalPromise<T> {
        resolve: (d?: T) => any;
        reject: (err?: any) => any;
        promise: Promise<T>;
        constructor();
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1' {
    import * as loadAssets from 'roboconnection/connection/jibo-command-requester/requests/v1/LoadAssets';
    import * as unloadAssets from 'roboconnection/connection/jibo-command-requester/requests/v1/UnloadAssets';
    import * as session from 'roboconnection/connection/jibo-command-requester/requests/v1/Session';
    import * as camera from 'roboconnection/connection/jibo-command-requester/requests/v1/camera';
    import * as expression from 'roboconnection/connection/jibo-command-requester/requests/v1/expression';
    import * as listen from 'roboconnection/connection/jibo-command-requester/requests/v1/listen';
    import * as lps from 'roboconnection/connection/jibo-command-requester/requests/v1/lps';
    import * as sensory from 'roboconnection/connection/jibo-command-requester/requests/v1/sensory';
    import * as settings from 'roboconnection/connection/jibo-command-requester/requests/v1/settings';
    export { loadAssets, unloadAssets, session, camera, expression, listen, lps, sensory, settings };
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v2' {
    import * as structural from 'roboconnection/connection/jibo-command-requester/requests/v2/structural';
    import * as emotion from 'roboconnection/connection/jibo-command-requester/requests/v2/emotion';
    import * as perception from 'roboconnection/connection/jibo-command-requester/requests/v2/perception';
    import * as play from 'roboconnection/connection/jibo-command-requester/requests/v2/Play';
    import * as listen from 'roboconnection/connection/jibo-command-requester/requests/v2/Listen';
    import * as display from 'roboconnection/connection/jibo-command-requester/requests/v2/Display';
    import * as slim from 'roboconnection/connection/jibo-command-requester/requests/v2/SLIM';
    /**
      * @description Namespace for the v2 RCP protocol.
      * </br> See [Phoenix RCP](https://github.jibo.com/phoenix/jibo-command-protocol) for all `JIBO` docs.
      * @namespace Requester.v2
      * @intdocs
      */
    export { play, listen, display, slim, perception, emotion, structural };
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/LoadAssets' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    /**
        * @class FetchAssetToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class FetchAssetToken extends RequestToken<JIBO.v1.FetchAssetRequest, JIBO.v1.FetchAssetEvent> {
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.FetchAssetRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls Jibo's Load asset management.
        * @namespace Requester.loadAssets
        */
    export class LoadAssets extends RequestAPI<JIBO.v1.FetchAssetRequest, FetchAssetToken> {
            /**
                * Generate loadAsset Protocol
                * @method Requester.loadAssets#generateProtocol
                * @param {string} uri - URI of the asset to be fetched.
                * @param {string} name - Name given to the asset for later reference (must be unique).
                * @returns {FetchAssetRequest}
                * @intdocs
                */
            static generateProtocol(uri: string, name: string): JIBO.v1.FetchAssetRequest;
            /**
                * Command to retrieve external asset and store in local cache by name.
                * @method Requester.loadAssets#fetchAsset
                * @param  {string}   uri Uri where the asset to fetch is.
                * @param  {string}   name Name that the asset will be call by.
                * @return {FetchAssetToken}
                */
            fetchAsset(uri: string, name: string): FetchAssetToken;
            /**
                * @method Requester.loadAssets#generateToken
                * @description Create FetchAssetToken from FetchAssetRequest protocol.
                * @param {FetchAssetRequest} protocol - FetchAssetRequest protocol to generate a FetchAssetToken from.
                * @param {boolean} [andSend=false] - `True` if the generated FetchAssetToken should also be sent as a request.
                * @return {FetchAssetToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.FetchAssetRequest, andSend?: boolean): FetchAssetToken;
            /**
                * Send FetchAssetToken request.
                * <p>NOTE: Implementation in base class {@link RequestAPI}</p>
                * @method Requester.loadAssets#sendToken
                * @param {FetchAssetToken} token - FetchAssetToken to send.
                * @intdocs
                */
            sendToken(token: FetchAssetToken): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/UnloadAssets' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    /**
        * @class UnloadAssetToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class UnloadAssetToken extends RequestToken<JIBO.v1.UnloadAssetRequest, JIBO.v1.UnloadAssetEvent> {
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.UnloadAssetRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls Jibo's asset management.
        * @namespace Requester.unloadAssets
        */
    export class UnloadAssets extends RequestAPI<JIBO.v1.UnloadAssetRequest, UnloadAssetToken> {
            /**
                * Generate Unload Asset Protocol
                * @method Requester.unloadAssets#generateProtocol
                * @param {string} name - Name given to the asset for later reference (must be unique).
                * @returns {UnloadAssetRequest}
                * @intdocs
                */
            static generateProtocol(name: string): JIBO.v1.UnloadAssetRequest;
            /**
                * Command unload asset by name.
                * @method Requester.unloadAssets#unloadAsset
                * @param  {string}   name Name of asset to unload.
                * @return {UnloadAssetToken}
                */
            unloadAsset(name: string): UnloadAssetToken;
            /**
                * @method Requester.unloadAssets#generateUnloadToken
                * @description Create UnloadAssetToken from UnloadAssetRequest protocol.
                * @param {UnloadAssetRequest} protocol - UnloadAssetRequest protocol to generate a UnloadAssetToken from.
                * @param {boolean} [andSend=false] - `True` if the generated UnloadAssetToken should also be sent as a request.
                * @return {UnloadAssetToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.UnloadAssetRequest, andSend?: boolean): UnloadAssetToken;
            /**
                * Send UnloadAssetToken request.
                * @method Requester.unloadAssets#sendToken
                * @param {UnloadAssetToken} token - UnloadAssetToken to send.
                * @intdocs
                */
            sendToken(token: UnloadAssetToken): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/Session' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    /**
        * @class SessionToken
        * @description Response token for the {@link Session} class.
        * @extends RequestToken
        * @hideconstructor
        */
    export class SessionToken extends RequestToken<JIBO.v1.SessionRequest, JIBO.v1.SessionResponse> {
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.SessionRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * @namespace Requester.session
        */
    export class Session extends RequestAPI<JIBO.v1.SessionRequest, SessionToken> {
            /**
                * Generate Session Protocol
                * @method Requester.session#generateProtocol
                * @returns {SessionRequest}
                * @intdocs
                */
            static generateProtocol(): JIBO.v1.SessionRequest;
            /**
                * Start the session.
                * @method Requester.session#startSession
                * @return {SessionToken}
                */
            startSession(): SessionToken;
            /**
                * @method Requester.session#generateToken
                * @description Create SessionToken from SessionRequest protocol.
                * @param {SessionRequest} protocol - SessionRequest protocol to generate a SessionToken from.
                * @param {boolean} [andSend=false] - `True` if the generated SessionToken should also be sent as a request.
                * @return {SessionToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.SessionRequest, andSend?: boolean): SessionToken;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/camera' {
    import * as photo from 'roboconnection/connection/jibo-command-requester/requests/v1/camera/Photo';
    import * as video from 'roboconnection/connection/jibo-command-requester/requests/v1/camera/Video';
    export { photo, video };
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/expression' {
    import * as attention from 'roboconnection/connection/jibo-command-requester/requests/v1/expression/Attention';
    import * as lookAt from 'roboconnection/connection/jibo-command-requester/requests/v1/expression/LookAt';
    import * as display from 'roboconnection/connection/jibo-command-requester/requests/v1/expression/Display';
    import * as play from 'roboconnection/connection/jibo-command-requester/requests/v1/expression/Play';
    import * as video from 'roboconnection/connection/jibo-command-requester/requests/v1/expression/VideoPlayback';
    export { attention, lookAt, display, play, video };
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/listen' {
    import * as hotWord from 'roboconnection/connection/jibo-command-requester/requests/v1/listen/HotWord';
    import * as listen from 'roboconnection/connection/jibo-command-requester/requests/v1/listen/Listen';
    export { hotWord, listen };
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/lps' {
    import * as face from 'roboconnection/connection/jibo-command-requester/requests/v1/lps/FaceTrack';
    import * as motion from 'roboconnection/connection/jibo-command-requester/requests/v1/lps/MotionTrack';
    export { face, motion };
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/sensory' {
    import * as headTouch from 'roboconnection/connection/jibo-command-requester/requests/v1/sensory/HeadTouch';
    import * as screenGesture from 'roboconnection/connection/jibo-command-requester/requests/v1/sensory/ScreenGesture';
    export { headTouch, screenGesture };
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/settings' {
    import * as getConfig from 'roboconnection/connection/jibo-command-requester/requests/v1/settings/GetConfig';
    import * as setConfig from 'roboconnection/connection/jibo-command-requester/requests/v1/settings/SetConfig';
    export { getConfig, setConfig };
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v2/structural' {
    /**
      * @namespace Requester.v2.structural
      * @intdocs
      */
    export * from 'roboconnection/connection/jibo-command-requester/requests/v2/structural/Parallel';
    export * from 'roboconnection/connection/jibo-command-requester/requests/v2/structural/Sequence';
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v2/emotion' {
    /**
      * @namespace Requester.v2.emotion
      * @intdocs
      */
    export * from 'roboconnection/connection/jibo-command-requester/requests/v2/emotion/ImpactEmotion';
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v2/perception' {
    /**
      * @namespace Requester.v2.perception
      * @intdocs
      */
    export * from 'roboconnection/connection/jibo-command-requester/requests/v2/perception/SetPresentPerson';
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v2/Play' {
    /**
        * @namespace Requester.v2.play
        * @intdocs
        */
    export class Play {
            /**
                * Generates Play Protocol. See [Phoenix RCP](https://github.jibo.com/phoenix/jibo-command-protocol) for `JIBO` docs.
                * @method Requester.v2.play#generateProtocol
                * @param {string} esml - ESML string to be spoken.
                * @param {(string|Object)} [config] - AutoRule configuration options for the Play request.
                * @param {Object} [options] - Speak options for the Play request.
                * @returns {JIBO.v2.behaviors.Play}
                */
            static generateProtocol(esml: string, config?: string | Object, options?: Object): JIBO.v2.behaviors.Play;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v2/Listen' {
    /**
        * @namespace Requester.v2.listen
        * @intdocs
        */
    export class Listen {
            /**
                * Generates Listen Protocol. See [Phoenix RCP](https://github.jibo.com/phoenix/jibo-command-protocol) for `JIBO` docs.
                * @method Requester.v2.listen#generateProtocol
                * @param {(string|string[])} ruleContext - Robust Parser Rules / Dialog Flow Agents we're listening for.
                * @param {JIBO.v2.behaviors.Intent[]} intents - Dialog Flow intents
                * @returns {JIBO.v2.behaviors.Listen}
                */
            static generateProtocol(rules: string | string[], intents?: JIBO.v2.behaviors.Intent[]): JIBO.v2.behaviors.Listen;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v2/Display' {
    /**
        * @namespace Requester.v2.display
        * @intdocs
        */
    export class Display {
            /**
                * Generates Display Protocol. See [Phoenix RCP](https://github.jibo.com/phoenix/jibo-command-protocol) for `JIBO` docs.
                * @method Requester.v2.display#generateProtocol
                * @param {string} name - Unique name of the Display.
                * @param {(JIBO.v2.behaviors.EyeDisplay | JIBO.v2.behaviors.NoneDisplay | JIBO.v2.behaviors.MenuDisplay | JIBO.v2.behaviors.Image | JIBO.v2.behaviors.PhotoGallery | JIBO.v2.behaviors.LoopMembersMenu | JIBO.v2.behaviors.SkillDisplay | JIBO.v2.behaviors.TextDisplay)} view - The view to be displayed.
                * @param {(0 | 1 | 2 | 3 | 4)} layer - Which layer the Display will be active on.
                * @param {boolean} visible - If `visible` is `false`, the display will not show until a ShowDisplayAction is called on it.
                * @param {boolean} keepDisplay - If `keepDisplay` is `true`, the display will stay upon completion until removed (?)
                * @param {JIBO.v2.behaviors.Action[]} onCancel - Action handlers for when the Display is cancelled.
                * @param {("dim" | "clear")} [overlay] - Overlay options for the Display.
                * @returns {JIBO.v2.behaviors.Display}
                */
            static generateProtocol(name: string, view: JIBO.v2.behaviors.EyeDisplay | JIBO.v2.behaviors.NoneDisplay | JIBO.v2.behaviors.MenuDisplay | JIBO.v2.behaviors.Image | JIBO.v2.behaviors.PhotoGallery | JIBO.v2.behaviors.LoopMembersMenu | JIBO.v2.behaviors.SkillDisplay | JIBO.v2.behaviors.TextDisplay, layer: 0 | 1 | 2 | 3 | 4, visible: boolean, keepDisplay: boolean, onCancel: JIBO.v2.behaviors.Action[], overlay?: "dim" | "clear"): JIBO.v2.behaviors.Display;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v2/SLIM' {
    /**
        * @namespace Requester.v2.slim
        * @intdocs
        */
    export class SLIM {
            /**
                * Generates SLIM Protocol. See [Phoenix RCP](https://github.jibo.com/phoenix/jibo-command-protocol) for `JIBO` docs.
                * @method Requester.v2.slim#generateProtocol
                * @param {JIBO.v2.behaviors.SLIMConfig} config - What components will comprise the SLIM.
                * @param {JIBO.v2.behaviors.SLIMOptions} [options] - Configuration options for the SLIM.
                * @returns {JIBO.v2.behaviors.SLIM}
                */
            static generateProtocol(config: JIBO.v2.behaviors.SLIMConfig, options?: JIBO.v2.behaviors.SLIMOptions): JIBO.v2.behaviors.SLIM;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/RequestAPI' {
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    export default abstract class RequestAPI<R extends JIBO.v1.BaseCommand, T extends RequestToken<R>> {
        protected owner: Requester;
        constructor(owner: Requester);
        abstract generateToken(protocol: R): T;
        sendToken(token: T): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/camera/Photo' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    /**
        * Reponse token for {@link Photo#takePhoto}.
        * @class PhotoToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class PhotoToken extends RequestToken<JIBO.v1.TakePhotoRequest, JIBO.v1.TakePhotoEvent> {
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.TakePhotoRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls Jibo's photo capture.
        * @namespace Requester.photo
        */
    export class Photo extends RequestAPI<JIBO.v1.TakePhotoRequest, PhotoToken> {
            /**
                * Generate Photo Protocol
                * @method Requester.photo#generateProtocol
                * @param {Camera} [camera=left] - Which camera to use -- left or right.
                * @param {CameraResolution} [resolution=LowRes] - Choose a resolution.
                * @param {boolean} [removeDistortion=true] - Use `false` for fisheye lense.
                * @returns {TakePhotoRequest}
                * @intdocs
                */
            static generateProtocol(camera?: JIBO.v1.Cameras.CameraType, resolution?: JIBO.v1.CameraResolutions.CameraResolutionType, removeDistortion?: boolean): JIBO.v1.TakePhotoRequest;
            /**
                * Take a photo.
                * @method Requester.photo#takePhoto
                * @param  {CameraResolution} [resolution=LowRes] Choose a resolution.
                * @param  {string}           [camera=left] Which camera to use -- left or right.
                * @param  {boolean}          [removeDistortion=true] Use `false` for fisheye lense.
                * @return {PhotoToken}
                */
            takePhoto(resolution?: JIBO.v1.CameraResolutions.CameraResolutionType, camera?: JIBO.v1.Cameras.CameraType, removeDistortion?: boolean): PhotoToken;
            /**
                * @method Requester.photo#generateToken
                * @description Create PhotoToken from TakePhotoRequest protocol.
                * @param {TakePhotoRequest} protocol - TakePhotoRequest protocol to generate a PhotoToken from.
                * @param {boolean} [andSend=false] - `True` if the generated PhotoToken should also be sent as a request.
                * @return {PhotoToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.TakePhotoRequest, andSend?: boolean): PhotoToken;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/camera/Video' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    import { Event } from 'roboconnection/connection/jibo-command-requester/events/Event';
    /**
        * Reponse token for {@link Video#getVideo}.
        * @class VideoToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class VideoToken extends RequestToken<JIBO.v1.VideoRequest, any> {
            /**
                * URL for video stream is ready.
                * @name VideoToken#streamReady
                * @type {Event<string>}
                */
            streamReady: Event<string>;
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.VideoRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls Jibo's video capture.
        * @namespace Requester.video
        */
    export class Video extends RequestAPI<JIBO.v1.VideoRequest, VideoToken> {
            /**
                * Generate Video Protocol
                * @method Requester.video#generateProtocol
                * @param {VideoType} [type=VideoType.Normal] - Choose a video type from the enum.
                * @param {number} [duration=0] - How long to record for (in ms).
                * @returns {VideoRequest}
                * @intdocs
                */
            static generateProtocol(type?: JIBO.v1.Videos.VideoType, duration?: number): JIBO.v1.VideoRequest;
            /**
                * Take a video.
                * @method Requester.video#getVideo
                * @param  {VideoType} [type=Normal] Choose a video type from the enum.
                * @param  {number}    [duration=0] How long to record for (in ms).
                * @return {VideoToken}
                */
            getVideo(type?: JIBO.v1.Videos.VideoType, duration?: number): VideoToken;
            /**
                * @method Requester.video#generateToken
                * @description Create VideoToken from VideoRequest protocol.
                * @param {VideoRequest} protocol - VideoRequest protocol to generate a VideoToken from.
                * @param {boolean} [andSend=false] - `True` if the generated VideoToken should also be sent as a request.
                * @return {VideoToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.VideoRequest, andSend?: boolean): VideoToken;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/expression/Attention' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    /**
        * Response token for the {@link Attention} class.
        * @class AttentionToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class AttentionToken extends RequestToken<JIBO.v1.AttentionRequest, void> {
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.AttentionRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls the Jibo's attention mode.
        * @namespace Requester.attention
        */
    export class Attention extends RequestAPI<JIBO.v1.AttentionRequest, AttentionToken> {
            /**
                * Generate Attention Protocol
                * @method Requester.attention#generateProtocol
                * @param {AttentionMode} mode - Mode to set Jibo's attention to.
                * @returns {AttentionRequest}
                * @intdocs
                */
            static generateProtocol(mode: JIBO.v1.AttentionModes.AttentionModeType): JIBO.v1.AttentionRequest;
            /**
                * Set Jibo's attention to a specific mode.
                * @method Requester.attention#setMode
                * @param  {AttentionMode}  mode Mode to set Jibo's attention to.
                * @return {AttentionToken}
                */
            setMode(mode: JIBO.v1.AttentionModes.AttentionModeType): AttentionToken;
            /**
                * @method Requester.attention#generateToken
                * @description Create AttentionToken from AttentionRequest protocol.
                * @param {AttentionRequest} protocol - AttentionRequest protocol to generate a AttentionToken from.
                * @param {boolean} [andSend=false] - `True` if the generated AttentionToken should also be sent as a request.
                * @return {AttentionToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.AttentionRequest, andSend?: boolean): AttentionToken;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/expression/LookAt' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    export interface LookAtAchievedResult {
            AngleTarget: JIBO.v1.AngleVector;
            PositionTarget: JIBO.v1.Vector3;
    }
    export interface LookAtTrackLostResult {
            EntityTarget: JIBO.v1.LookAtEntity;
            AngleTarget: JIBO.v1.AngleVector;
            PositionTarget: JIBO.v1.Vector3;
    }
    /**
        * Target options for LookAt
        * @typedef TargetMode
        * @prop Positoin
        * @prop Angle
        * @prop Entity
        * @prop Scren
        * @intdocs
        */
    export enum TargetMode {
            Position = 0,
            Angle = 1,
            Entity = 2,
            Screen = 3
    }
    /**
        * Reponse token for {@link LookAt} APIs.
        * @class LookAtToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class LookAtToken extends RequestToken<JIBO.v1.LookAtRequest, LookAtAchievedResult | LookAtTrackLostResult> {
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.LookAtRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls Jibo's LookAt movement.
        * @namespace Requester.lookAt
        */
    export class LookAt extends RequestAPI<JIBO.v1.LookAtRequest, LookAtToken> {
            /**
                * Generate LookAt Protocol
                * @method Requester.lookAt#generateProtocol
                * @param {TargetMode} targetMode - How we are targetting our target (depends on the target type)
                * @param {(Vector2|Vector3|LookAtEntity)} target - What we're looking at (Entity, Angle or Point in space)
                * @param {boolean} levelHead - `true` to keep Jibo's head level while he moves.
                * @param {boolean} [shouldTrack=false] - If we should track the target entity (Entity-Mode only)
                * @returns {LookAtRequest}
                * @intdocs
                */
            static generateProtocol(targetMode: TargetMode, target: JIBO.v1.Vector2 | JIBO.v1.Vector3 | JIBO.v1.LookAtEntity, levelHead: boolean, shouldTrack?: boolean): JIBO.v1.LookAtRequest;
            /**
                * @method Requester.lookAt#position
                * @description Look toward a 3D point in space.
                * @param  {Vector3}     target 3D point to look at (`[x, y, z]`).
                * @param  {boolean}     [levelHead=true] `true` to keep Jibo's head level while he moves.
                * @return {LookAtToken}
                */
            position(target: JIBO.v1.Vector3, levelHead?: boolean): LookAtToken;
            /**
                * @method Requester.lookAt#angle
                * @description Look at an angle.
                * @param  {AngleVector}    target Angle to look at (`[theta, psi]`).
                * @param  {boolean}        [levelHead=true] `true` to keep Jibo's head level while he moves.
                * @return {LookAtToken}
                */
            angle(target: JIBO.v1.AngleVector, levelHead?: boolean): LookAtToken;
            /**
                * @method Requester.lookAt#screenPosition
                * @description Look at a point relative to Jibo's screen.
                * @param  {Vector2}     target Point to look at (`[x, y, width, height]`).
                * @param  {boolean}     [levelHead=true] `true` to keep Jibo's head level while he moves.
                * @return {LookAtToken}
                */
            screenPosition(target: JIBO.v1.Vector2, levelHead?: boolean): LookAtToken;
            /**
                * @method Requester.lookAt#entity
                * @description Look at an entity (usually a face).
                * @param  {LookAtEntity}   target Entity to look at.
                * @param  {boolean}        [levelHead=true] `true` to keep Jibo's head level while he moves.
                * @return {LookAtToken}
                */
            entity(target: JIBO.v1.LookAtEntity, shouldTrack: boolean, levelHead?: boolean): LookAtToken;
            /**
                * @method Requester.lookAt#generateToken
                * @description Create LookAtToken from LookAtRequest protocol.
                * @param {LookAtRequest} protocol - LookAtRequest protocol to generate a LookAtToken from.
                * @param {boolean} [andSend=false] - `True` if the generated LookAtToken should also be sent as a request.
                * @return {LookAtToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.LookAtRequest, andSend?: boolean): LookAtToken;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/expression/Display' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    import { Event } from 'roboconnection/connection/jibo-command-requester/events/Event';
    /**
        * Reponse token for {@link Display} APIs.
        * @class DisplayToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class DisplayToken extends RequestToken<JIBO.v1.DisplayRequest> {
            /**
                * Emitted when a display view is opened.
                * @name DisplayToken#opened
                * @type {Event}
                */
            opened: Event<void>;
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.DisplayRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls which views appear on Jibo's screen.
        * @namespace Requester.display
        */
    export class Display extends RequestAPI<JIBO.v1.DisplayRequest, DisplayToken> {
            /**
                * Generate Display Protocol
                * @method Requester.display#generateProtocol
                * @param {(EyeView | TextView | ImageView)} view - View to replace the existing one with.
                * @returns {DisplayRequest}
                * @intdocs
                */
            static generateProtocol(view: JIBO.v1.EyeView | JIBO.v1.TextView | JIBO.v1.ImageView): JIBO.v1.DisplayRequest;
            swap(view: JIBO.v1.EyeView | JIBO.v1.TextView | JIBO.v1.ImageView): DisplayToken;
            /**
                * @method Requester.display#swapView
                * @description Replace the existing view with the one given.
                * @param  {EyeView | TextView | ImageView}  view View to replace the existing one with.
                * @return {DisplayToken}
                */
            swapView(view: JIBO.v1.EyeView | JIBO.v1.TextView | JIBO.v1.ImageView): DisplayToken;
            /**
                * @method Requester.display#createEyeView
                * @description Create a view to display Jibo's eye on screen.
                * @param  {string} name Unique name of view.
                * @return {EyeView}
                */
            createEyeView(name: string): JIBO.v1.EyeView;
            /**
                * @method Requester.display#createTextView
                * @description Create a view to display text on Jibo's screen.
                * @param  {string} name Unique name of view.
                * @param  {string} text Text to display on screen.
                * @return {TextView}
                */
            createTextView(name: string, text: string): JIBO.v1.TextView;
            /**
                * @method Requester.display#createImageView
                * @description Create a view to display an image on Jibo's screen.
                * @param  {string} name Unique name of view.
                * @param  {ImageData} data Data for retrieving image.
                * @return {ImageView}
                */
            createImageView(name: string, data: JIBO.v1.ImageData): JIBO.v1.ImageView;
            /**
                * @method Requester.display#generateToken
                * @description Create DisplayToken from DisplayRequest protocol.
                * @param {DisplayRequest} protocol - DisplayRequest protocol to generate a DisplayToken from.
                * @param {boolean} [andSend=false] - `True` if the generated DisplayToken should also be sent as a request.
                * @return {DisplayToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.DisplayRequest, andSend?: boolean): DisplayToken;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/expression/Play' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    /**
        * @class SayToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class SayToken extends RequestToken<JIBO.v1.SayRequest> {
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.SayRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls Jibo's speech and audio.
        * @namespace Requester.play
        */
    export class Play extends RequestAPI<JIBO.v1.SayRequest, SayToken> {
            /**
                * Generate Play Protocol
                * @method Requester.play#generateProtocol
                * @param {string} esml_uri - ESML to speak or URI of sound to play
                * @param {JIBO.v1.SpeakOptions} [speakOptions] Options to configure , can be used in conjunction with ESML strings.
                * @param {JIBO.v1.AutoRuleConfig} [autoRuleConfig] Configuration for AutoRules , can be used in conjunction with ESML strings.
                * @returns {SayRequest}
                * @intdocs
                */
            static generateProtocol(esmlUri: string, speakOptions?: JIBO.v1.SpeakOptions, autoRuleConfig?: JIBO.v1.AutoRuleConfig): JIBO.v1.SayRequest;
            /**
                * Make Jibo speak.
                * @method Requester.play#say
                * @param  {string}   esml Embodied Speech Markup Language to say. See the [ESML Documentation]{@tutorial esml}.
                * @param {JIBO.v1.SpeakOptions} [speakOptions] Options to configure , can be used in conjunction with ESML strings.
                * @param {JIBO.v1.AutoRuleConfig} [autoRuleConfig] Configuration for AutoRules , can be used in conjunction with ESML strings.
                * @return {SayToken}
                */
            say(esml: string, speakOptions?: JIBO.v1.SpeakOptions, autoRuleConfig?: JIBO.v1.AutoRuleConfig): SayToken;
            /**
                * Make Jibo play a sound.
                * @method Requester.play#sound
                * @param  {string}   uri URI to the sound to play.
                * @return {SayToken}
                */
            sound(uri: string): SayToken;
            /**
                * @method Requester.play#generateToken
                * @description Create SayToken from SayRequest protocol.
                * @param {SayRequest} protocol - SayRequest protocol to generate a SayToken from.
                * @param {boolean} [andSend=false] - `True` if the generated SayToken should also be sent as a request.
                * @return {SayToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.SayRequest, andSend?: boolean): SayToken;
            /**
                * Send SayToken request.
                * <p>NOTE: Implementation in base class {@link RequestAPI}</p>
                * @method Requester.play#sendToken
                * @param {SayToken} token - SayToken to send.
                * @intdocs
                */
            sendToken(token: SayToken): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/expression/VideoPlayback' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    /**
        * Response token for the {@link VideoPlayback} class.
        * @class AttentionToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class VideoPlaybackToken extends RequestToken<JIBO.v1.VideoPlaybackRequest, void> {
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.VideoPlaybackRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls the Jibo's attention mode.
        * @namespace Requester.attention
        */
    export class VideoPlayback extends RequestAPI<JIBO.v1.VideoPlaybackRequest, VideoPlaybackToken> {
            /**
                * Generate Attention Protocol
                * @method Requester.attention#generateProtocol
                * @param {AttentionMode} mode - Mode to set Jibo's attention to.
                * @returns {AttentionRequest}
                * @intdocs
                */
            static generateProtocol(url: string): JIBO.v1.VideoPlaybackRequest;
            /**
                * Set Jibo's attention to a specific mode.
                * @method Requester.attention#setMode
                * @param  {AttentionMode}  mode Mode to set Jibo's attention to.
                * @return {AttentionToken}
                */
            play(url: string): VideoPlaybackToken;
            /**
                * @method Requester.attention#generateToken
                * @description Create AttentionToken from AttentionRequest protocol.
                * @param {AttentionRequest} protocol - AttentionRequest protocol to generate a AttentionToken from.
                * @param {boolean} [andSend=false] - `True` if the generated AttentionToken should also be sent as a request.
                * @return {AttentionToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.VideoPlaybackRequest, andSend?: boolean): VideoPlaybackToken;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/listen/HotWord' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    import { Event } from 'roboconnection/connection/jibo-command-requester/events/Event';
    /**
        * @class HotWordToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class HotWordToken extends RequestToken<JIBO.v1.HotWordRequest> {
            /**
                * Heard "Hey Jibo"
                * @name HotWordToken#hotWordHeard
                * @type {Event}
                */
            hotWordHeard: Event<JIBO.v1.HotWordHeardEvent>;
            /**
                * Result of what Jibo head is available.
                * @name HotWordToken#listenResult
                * @type {Event<string>}
                */
            listenResult: Event<string>;
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.HotWordRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls Jibo's HotWord Listening.
        * CURRENTLY UNSUPPORTED
        * @namespace Requester.hotWord
        */
    export class HotWord extends RequestAPI<JIBO.v1.HotWordRequest, HotWordToken> {
            /**
                * Generate HotWord Protocol
                * @method Requester.hotWord#generateProtocol
                * @param {boolean} [listen=false] - Whether to listen for additional speech input after "Hey Jibo" is heard.
                * @returns {HotWordRequest}
                * @intdocs
                */
            static generateProtocol(listen?: boolean): JIBO.v1.HotWordRequest;
            /**
                * Listen for "Hey Jibo".
                * @method Requester.hotWord#listen
                * @param {boolean} [listen = false] Whether to listen for additional speech input after "Hey Jibo" is heard.
                * @return {HotWordToken}
                */
            listen(listen?: boolean): HotWordToken;
            /**
                * @method Requester.hotWord#generateToken
                * @description Create HotWordToken from HotWordRequest protocol.
                * @param {HotWordRequest} protocol - HotWordRequest protocol to generate a HotWordToken from.
                * @param {boolean} [andSend=false] - `True` if the generated HotWordToken should also be sent as a request.
                * @return {HotWordToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.HotWordRequest, andSend?: boolean): HotWordToken;
            /**
                * Send HotWordToken request.
                * <p>NOTE: Implementation in base class {@link RequestAPI}</p>
                * @method Requester.hotWord#sendToken
                * @param {HotWordToken} token - HotWordToken to send.
                * @intdocs
                */
            sendToken(token: HotWordToken): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/listen/Listen' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import { Event } from 'roboconnection/connection/jibo-command-requester/events/Event';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    /**
        * Request token for the {@link Listen} class.
        * @class ListenToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class ListenToken extends RequestToken<JIBO.v1.ListenRequest, JIBO.v1.ListenResultEvent | JIBO.v1.ListenStopEvent> {
            /**
                * Listen token was updated. See [RCP Docs](https://github.jibo.com/phoenix/jibo-command-protocol) for docs.
                * @name ListenToken#update
                * @type {Event<JIBO.v1.ListenResultEvent>}
                */
            update: Event<JIBO.v1.ListenResultEvent>;
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.ListenRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls Jibo's Listening.
        * @namespace Requester.listen
        */
    export class Listen extends RequestAPI<JIBO.v1.ListenRequest, ListenToken> {
            /**
                * Generate Listen Protocol
                * @method Requester.listen#generateProtocol
                * @param {number} [maxSpeechTimeout=15] - Max speech timeout (in seconds)
                * @param {number} [maxNoSpeechTimeout=15] - Max no speech timeout (in seconds)
                * @param {string} [languageCode='en-US'] - Language code
                * @returns {ListenRequest}
                * @intdocs
                */
            static generateProtocol(maxSpeechTimeout?: number, maxNoSpeechTimeout?: number, languageCode?: string): JIBO.v1.ListenRequest;
            subscribe: {
                    hotword: any;
            };
            start(maxSpeechTimeout?: number, maxNoSpeechTimeout?: number, languageCode?: string): ListenToken;
            /**
                * Request for the robot to listen.
                * @method Requester.listen#listen
                * @param  {number}   [maxSpeechTimeout = 15] In seconds
                * @param  {number}   [maxNoSpeechTimeout = 15] In seconds
                * @param  {number}   [languageCode = en_US]
                * @return {ListenToken}
                */
            listen(maxSpeechTimeout?: number, maxNoSpeechTimeout?: number, languageCode?: string): ListenToken;
            /**
                * @method Requester.listen#generateToken
                * @description Create ListenToken from ListenRequest protocol.
                * @param {ListenRequest} protocol - ListenRequest protocol to generate a ListenToken from.
                * @param {boolean} [andSend=false] - `True` if the generated ListenToken should also be sent as a request.
                * @return {ListenToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.ListenRequest, andSend?: boolean): ListenToken;
            /**
                * Send ListenToken request.
                * <p>NOTE: Implementation in base class {@link RequestAPI}</p>
                * @method Requester.listen#sendToken
                * @param {ListenToken} token - ListenToken to send.
                * @intdocs
                */
            sendToken(token: ListenToken): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/lps/FaceTrack' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    import { Event } from 'roboconnection/connection/jibo-command-requester/events/Event';
    /**
        * Request token for the {@link FaceTrack} class.
        * @class FaceTrackToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class FaceTrackToken extends RequestToken<JIBO.v1.EntityRequest, any> {
            /**
                * Update on location of face being tracked.
                * @name FaceTrackToken#update
                * @type {Event<TrackedEntity[]>}
                */
            update: Event<JIBO.v1.TrackedEntity[]>;
            /**
                * New face being tracked.
                * @name FaceTrackToken#gained
                * @type {Event<TrackedEntity[]>}
                */
            gained: Event<JIBO.v1.TrackedEntity[]>;
            /**
                * Currently tracked face was lost.
                * @name FaceTrackToken#lost
                * @type {Event<TrackedEntity[]>}
                */
            lost: Event<JIBO.v1.TrackedEntity[]>;
            constructor(owner: Requester, protocol: JIBO.v1.EntityRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls Jibo's face tracking.
        * @namespace Requester.faceTrack
        */
    export class FaceTrack extends RequestAPI<JIBO.v1.EntityRequest, FaceTrackToken> {
            /**
                * Generate Face Track Protocol
                * @method Requester.faceTrack#generateProtocol
                * @returns {EntityRequest}
                * @intdocs
                */
            static generateProtocol(): JIBO.v1.EntityRequest;
            /**
                * @method Requester.faceTrack#trackFaces
                * @description Track all faces in Jibo's field of vision.
                * @return {FaceTrackToken}
                */
            trackFaces(): FaceTrackToken;
            /**
                * @method Requester.faceTrack#generateToken
                * @description Create FaceTrackToken from EntityRequest protocol.
                * @param {EntityRequest} protocol - EntityRequest protocol to generate a FaceTrackToken from.
                * @param {boolean} [andSend=false] - `True` if the generated FaceTrackToken should also be sent as a request.
                * @return {FaceTrackToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.EntityRequest, andSend?: boolean): FaceTrackToken;
            /**
                * Send FaceTrackToken request.
                * <p>NOTE: Implementation in base class {@link RequestAPI}</p>
                * @method Requester.faceTrack#sendToken
                * @param {FaceTrackToken} token - FaceTrackToken to send.
                * @intdocs
                */
            sendToken(token: FaceTrackToken): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/lps/MotionTrack' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    import { Event } from 'roboconnection/connection/jibo-command-requester/events/Event';
    /**
        * Request token for the {@link MotionTrack} class.
        * @class MotionToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class MotionToken extends RequestToken<JIBO.v1.MotionRequest, any> {
            /**
                * @name MotionToken#update
                * @type {Event<MotionEntity[]>}
                */
            update: Event<JIBO.v1.MotionEntity[]>;
            constructor(owner: Requester, protocol: JIBO.v1.MotionRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls Jibo's mostion tracking.
        * @namespace Requester.motionTrack
        */
    export class MotionTrack extends RequestAPI<JIBO.v1.MotionRequest, MotionToken> {
            /**
                * Generate Motion Track Protocol
                * @method Requester.motionTrack#generateProtocol
                * @returns {MotionRequest}
                * @intdocs
                */
            static generateProtocol(): JIBO.v1.MotionRequest;
            /**
                * @method Requester.motionTrack#trackMotions
                * @description Track all motions in Jibo's field of vision.
                * @return {MotionToken}
                */
            trackMotions(): MotionToken;
            /**
                * @method Requester.motionTrack#generateToken
                * @description Create MotionToken from MotionRequest protocol.
                * @param {MotionRequest} protocol - MotionRequest protocol to generate a MotionToken from.
                * @param {boolean} [andSend=false] - `True` if the generated MotionToken should also be sent as a request.
                * @return {MotionToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.MotionRequest, andSend?: boolean): MotionToken;
            /**
                * Send MotionToken request.
                * <p>NOTE: Implementation in base class {@link RequestAPI}</p>
                * @method Requester.motionTrack#sendToken
                * @param {MotionToken} token - MotionToken to send.
                * @intdocs
                */
            sendToken(token: MotionToken): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/sensory/HeadTouch' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    import { Event } from 'roboconnection/connection/jibo-command-requester/events/Event';
    /**
        * @class HeadTouchToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class HeadTouchToken extends RequestToken<JIBO.v1.HeadTouchRequest> {
            /**
                * One or more of Jibo's touchpad sensors was touched.
                * @name HeadTouchToken#HeadTouchEvent
                * @type {Event}
                */
            update: Event<boolean[]>;
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.HeadTouchRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls subscription to Head Touch events
        * @namespace Requester.headTouch
        */
    export class HeadTouch extends RequestAPI<JIBO.v1.HeadTouchRequest, HeadTouchToken> {
            /**
                * Generate Head Touch Protocol
                * @method Requester.headTouch#generateProtocol
                * @returns {HeadTouchRequest}
                * @intdocs
                */
            static generateProtocol(): JIBO.v1.HeadTouchRequest;
            /**
                * Listen for head touch.
                * @method Requester.headTouch#listen
                * @return {HeadTouchToken}
                */
            listen(): HeadTouchToken;
            /**
                * @method Requester.headTouch#generateToken
                * @description Create HeadTouchToken from HeadTouchRequest protocol.
                * @param {HeadTouchRequest} protocol - HeadTouchRequest protocol to generate a HeadTouchToken from.
                * @param {boolean} [andSend=false] - `True` if the generated HeadTouchToken should also be sent as a request.
                * @return {HeadTouchToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.HeadTouchRequest, andSend?: boolean): HeadTouchToken;
            /**
                * Send HeadTouchToken request.
                * <p>NOTE: Implementation in base class {@link RequestAPI}</p>
                * @method Requester.headTouch#sendToken
                * @param {HeadTouchToken} token - HeadTouchToken to send.
                * @intdocs
                */
            sendToken(token: HeadTouchToken): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/sensory/ScreenGesture' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    import { Event } from 'roboconnection/connection/jibo-command-requester/events/Event';
    /**
        * Reponse token for {@link ScreenGesture} APIs.
        * @class ScreenGestureToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class ScreenGestureToken extends RequestToken<JIBO.v1.ScreenGestureRequest> {
            /**
                * Tap screen gesture. `[x,y]` of tap location type.
                * @name ScreenGestureToken#tap
                * @type {Event<Vector2>}
                */
            tap: Event<JIBO.v1.Vector2>;
            /**
                * Swipe screen gesture. Type is direction of swipe.
                * @name ScreenGestureToken#swipe
                * @type {Event<SwipeDirection>}
                */
            swipe: Event<JIBO.v1.SwipeDirections.SwipeDirectionType>;
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.ScreenGestureRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Allows subsription to the events emited when a gesture is detected in the Jibo screen.
        * @namespace Requester.screenGesture
        */
    export class ScreenGesture extends RequestAPI<JIBO.v1.ScreenGestureRequest, ScreenGestureToken> {
            /**
                * Generate Screen Gesture Protocol
                * @method Requester.screenGesture#generateProtocol
                * @param {ScreenGestureFilter} [filter={}]
                * @returns {ScreenGestureRequest}
                * @intdocs
                */
            static generateProtocol(filter?: JIBO.v1.ScreenGestureFilter): JIBO.v1.ScreenGestureRequest;
            /**
                * @method Requester.screenGesture#subscribe
                * @description Listen for screen touch input.
                * @param  {ScreenGestureFilter}  filter Data for screen touch info, including type of gesture to listen
                * for and area to listen in.
                * @return {ScreenGestureToken}
                */
            subscribe(filter?: JIBO.v1.ScreenGestureFilter): ScreenGestureToken;
            /**
                * @method Requester.screenGesture#generateToken
                * @description Create ScreenGestureToken from ScreenGestureRequest protocol.
                * @param {ScreenGestureRequest} protocol - ScreenGestureRequest protocol to generate a ScreenGestureToken from.
                * @param {boolean} [andSend=false] - `True` if the generated ScreenGestureToken should also be sent as a request.
                * @return {ScreenGestureToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.ScreenGestureRequest, andSend?: boolean): ScreenGestureToken;
            /**
                * Send ScreenGestureToken request.
                * <p>NOTE: Implementation in base class {@link RequestAPI}</p>
                * @method Requester.screenGesture#sendToken
                * @param {ScreenGestureToken} token - ScreenGestureToken to send.
                * @intdocs
                */
            sendToken(token: ScreenGestureToken): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/settings/GetConfig' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    /**
        * @class GetConfigToken
        * @description Response token for the {@link GetConfig#get} class.
        * @extends RequestToken
        * @hideconstructor
        */
    export class GetConfigToken extends RequestToken<JIBO.v1.GetConfigRequest, JIBO.v1.ConfigEvent> {
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.GetConfigRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls getting robot configuration options
        * @namespace Requester.getConfig
        */
    export class GetConfig extends RequestAPI<JIBO.v1.GetConfigRequest, GetConfigToken> {
            /**
                * Generate Get Config Protocol
                * @method Requester.getConfig#generateProtocol
                * @returns {GetConfigRequest}
                * @intdocs
                */
            static generateProtocol(): JIBO.v1.GetConfigRequest;
            /**
                * Get robot configuration options.
                * @method Requester.getConfig#get
                * @return {GetConfigToken}
                */
            get(): GetConfigToken;
            /**
                * @method Requester.getConfig#generateToken
                * @description Create GetConfigToken from GetConfigRequest protocol.
                * @param {GetConfigRequest} protocol - GetConfigRequest protocol to generate a GetConfigToken from.
                * @param {boolean} [andSend=false] - `True` if the generated GetConfigToken should also be sent as a request.
                * @return {GetConfigToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.GetConfigRequest, andSend?: boolean): GetConfigToken;
            /**
                * Send GetConfigToken request.
                * <p>NOTE: Implementation in base class {@link RequestAPI}</p>
                * @method Requester.getConfig#sendToken
                * @param {GetConfigToken} token - GetConfigToken to send.
                * @intdocs
                */
            sendToken(token: GetConfigToken): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/settings/SetConfig' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    /**
        * @class SetConfigToken
        * @description Response token for the {@link SetConfig#set} class.
        * @extends RequestToken
        * @hideconstructor
        */
    export class SetConfigToken extends RequestToken<JIBO.v1.SetConfigRequest> {
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.SetConfigRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls setting robot configuration options
        * @namespace Requester.setConfig
        */
    export class SetConfig extends RequestAPI<JIBO.v1.SetConfigRequest, SetConfigToken> {
            /**
                * Generate Set Config Protocol
                * @method Requester.setConfig#generateProtocol
                * @param {SetConfigOptions} options
                * @returns {SetConfigRequest}
                * @intdocs
                */
            static generateProtocol(options: JIBO.v1.SetConfigOptions): JIBO.v1.SetConfigRequest;
            /**
                * Set robot configuration options.
                * @method Requester.setConfig#set
                * @param  {number}  mixer Volume between 0 (mute) and 1 (loudest).
                * @return {SetConfigToken}
                */
            set(options: JIBO.v1.SetConfigOptions): SetConfigToken;
            /**
                * @method Requester.setConfig#generateToken
                * @description Create SetConfigToken from SetConfigRequest protocol.
                * @param {SetConfigRequest} protocol - SetConfigRequest protocol to generate a SetConfigToken from.
                * @param {boolean} [andSend=false] - `True` if the generated SetConfigToken should also be sent as a request.
                * @return {SetConfigToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.SetConfigRequest, andSend?: boolean): SetConfigToken;
            /**
                * Send SetConfigToken request.
                * <p>NOTE: Implementation in base class {@link RequestAPI}</p>
                * @method Requester.setConfig#sendToken
                * @param {SetConfigToken} token - SetConfigToken to send.
                * @intdocs
                */
            sendToken(token: SetConfigToken): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v2/structural/Parallel' {
    /**
        * @class Requester.v2.structural.Parallel
        * @intdocs
        */
    export class Parallel {
            /**
                * Generates Parallel Protocol. See [Phoenix RCP](https://github.jibo.com/phoenix/jibo-command-protocol) for `JIBO` docs.
                * @method Requester.v2.structural.Parallel#generateProtocol
                * @param {JIBO.v2.behaviors.Behavior[]} behaviors - Behaviors to execute in parallel
                * @param {JIBO.v2.behaviors.Behavior[]} [succeedOnFirst=false] - `true` if the entire behavior should succeed when the child who suceeds first does.
                * @returns {JIBO.v2.behaviors.Parallel}
                */
            static generateProtocol(behaviors: JIBO.v2.behaviors.Behavior[], succeedOnFirst?: boolean): JIBO.v2.behaviors.Parallel;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v2/structural/Sequence' {
    /**
        * @class Requester.v2.structural.Sequence
        * @intdocs
        */
    export class Sequence {
            /**
                * Generates Sequence Protocol. See [Phoenix RCP](https://github.jibo.com/phoenix/jibo-command-protocol) for `JIBO` docs.
                * @method Requester.v2.structural.Sequence#generateProtocol
                * @param {JIBO.v2.behaviors.Behavior[]} behaviors - Behaviors to execute in sequence
                * @returns {JIBO.v2.behaviors.Sequence}
                */
            static generateProtocol(behaviors: JIBO.v2.behaviors.Behavior[]): JIBO.v2.behaviors.Sequence;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v2/emotion/ImpactEmotion' {
    /**
        * @class Requester.v2.emotion.ImpactEmotion
        * @intdocs
        */
    export class ImpactEmotion {
            /**
                * Generates ImpactEmotion Protocol. See [Phoenix RCP](https://github.jibo.com/phoenix/jibo-command-protocol) for `JIBO` docs.
                * @method Requester.v2.emotion.ImpactEmotion#generateProtocol
                * @param {("NONE" | "LOW_POS" | "MEDIUM_POS" | "HIGH_POS" | "LOW_NEG" | "MEDIUM_NEG" | "HIGH_NEG")} [valence] - Impact the valence axis
                * @param {("NONE" | "LOW_POS" | "MEDIUM_POS" | "HIGH_POS" | "LOW_NEG" | "MEDIUM_NEG" | "HIGH_NEG")} [confidence] - Impact the confidence axis
                * @returns {JIBO.v2.behaviors.ImpactEmotion}
                */
            static generateProtocol(valence?: "NONE" | "LOW_POS" | "MEDIUM_POS" | "HIGH_POS" | "LOW_NEG" | "MEDIUM_NEG" | "HIGH_NEG", confidence?: "NONE" | "LOW_POS" | "MEDIUM_POS" | "HIGH_POS" | "LOW_NEG" | "MEDIUM_NEG" | "HIGH_NEG"): JIBO.v2.behaviors.ImpactEmotion;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v2/perception/SetPresentPerson' {
    /**
        * @class Requester.v2.perception.SetPresentPerson
        * @intdocs
        */
    export class SetPresentPerson {
            /**
                * Generates SetPresentPerson Protocol. See [Phoenix RCP](https://github.jibo.com/phoenix/jibo-command-protocol) for `JIBO` docs.
                * @method Requester.v2.perception.SetPresentPerson#generateProtocol
                * @param {string} looperId - Loop member's ID
                * @param {("VOICE" | "FACE" | "USER_OVERRIDE")} source - Source of the ID
                * @param {number} confidence - Confidence level in this claim of presence
                * @returns {JIBO.v2.behaviors.SetPresentPerson}
                */
            static generateProtocol(looperId: string, source: "VOICE" | "FACE" | "USER_OVERRIDE", confidence: number): JIBO.v2.behaviors.SetPresentPerson;
    }
}

