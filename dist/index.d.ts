// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../events

declare module 'roboconnection' {
    /** JIBO declarations are now included below... **/
    import { JiboConnection, ConnectionInfo, RobotInfo } from 'roboconnection/connection/JiboConnection';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    export { JiboConnection, ConnectionInfo, RobotInfo, Requester };
    global {
            namespace JIBO {
                    namespace ProtocolVersions {
                            type v1 = '1.0';
                            type v2 = '2.0';
                            type ProtocolVersionType = v1 | v2;
                    }
                    namespace v1 {
                            namespace ResponseCodes {
                                    /** The command was accepted and executed. Synchronous calls only. */
                                    type OK = 200;
                                    /** The command was accepted and executed. Synchronous calls only */
                                    type Created = 201;
                                    /** The command was accepted and will begin execution. Most asynchronous commands will get a this response */
                                    type Accepted = 202;
                                    /** Badly formatted request */
                                    type BadRequest = 400;
                                    /** The command request is not a supported command */
                                    type Forbidden = 403;
                                    /** Command not found */
                                    type NotFound = 404;
                                    /** The data in the command is not acceptable */
                                    type NotAcceptable = 406;
                                    /** Unable to marshal the resources and set up the command within the time limits set in the Controller */
                                    type RequestTimeout = 407;
                                    /** There is a conflicting command already executing */
                                    type Conflict = 409;
                                    /** The execution of the command requires the execution of a prior command */
                                    type PreconditionFailed = 412;
                                    /** The Controller has crashed or hit a different error that was unexpected */
                                    type InternalError = 500;
                                    /** The Controller is temporarily unavailable. The Robot SSM may be rebooting something */
                                    type ServiceUnavailable = 503;
                                    /** The Version requested is not supported */
                                    type VersionNotSupported = 505;
                                    /** The Version requested is not the same version of the current connection. */
                                    type VersionConflict = 506;
                                    type ResponseCodeType = OK | Created | Accepted | BadRequest | Forbidden | NotFound | NotAcceptable | RequestTimeout | Conflict | PreconditionFailed | InternalError | ServiceUnavailable | VersionNotSupported | VersionConflict;
                            }
                            interface ResponseStrings {
                                    200: 'OK';
                                    201: 'Created';
                                    202: 'Accepted';
                                    400: 'Bad Request';
                                    403: 'Forbidden';
                                    404: 'Not Found';
                                    406: 'Not Acceptable';
                                    407: 'Request Timeout';
                                    409: 'Conflict';
                                    412: 'Precondition Failed';
                                    500: 'Internal Error';
                                    503: 'Service Unavailable';
                                    505: 'Version Not Supported';
                                    506: 'Version Conflict';
                            }
                            /**
                                * Response body.
                                */
                            interface AcknowledgementBody {
                                    Value: 'Success' | 'Error';
                                    ResponseCode: ResponseCodes.ResponseCodeType;
                                    ResponseString: string;
                            }
                            /**
                                * Response body when error.
                                */
                            interface DetailErrorResponse extends AcknowledgementBody {
                                    /** Note with debugging purposes */
                                    ErrorDetail: string;
                            }
                            /**
                                * The Application Control Object. This describes the permissions of a skill.
                                */
                            interface ACO {
                                    /**
                                        * The version of this ACO object. This allows us
                                        * to update and refine the command set in the future
                                        */
                                    version: string;
                                    /** Unique Id for user of the protocol */
                                    sourceId: string;
                                    /** List of commands/behaviors this session is permitted to execute */
                                    commandSet: Commands.CommandType[];
                                    /** List of streams this session is permitted to listen to */
                                    streamSet: Streams.StreamType[];
                                    /** Interval, in milliseconds, heartbeats are sent, defaults to ever 10 sec */
                                    keepAliveTimeout?: number;
                                    /** Maximum wait, in milliseconds, between heartbeats, defaults to 20 sec */
                                    recoveryTimeout?: number;
                                    /** Configuration for remote mode, if not supplied indicates non-remote usage */
                                    remoteConfig?: RemoteOptions;
                                    test?: boolean;
                            }
                            /**
                                * Specific permissions and settings for remote usage of the Application Control Object.
                                */
                            interface RemoteOptions {
                                    /** Time for headTouch to exit remote mode */
                                    headTouchStopTime?: number;
                                    hideVisualCue?: boolean;
                                    /** Maximum time a session can go without receivig a command before ending the connection */
                                    inactivityTimeout?: number;
                            }
                            /**
                                * Jibo's available attention modes.
                                */
                            namespace AttentionModes {
                                    type Off = 'OFF';
                                    type Idle = 'IDLE';
                                    type Disengage = 'DISENGAGE';
                                    type Engaged = 'ENGAGED';
                                    type Speaking = 'SPEAKING';
                                    type Fixated = 'FIXATED';
                                    type Attractable = 'ATTRACTABLE';
                                    type Menu = 'MENU';
                                    type Command = 'COMMAND';
                                    type AttentionModeType = Off | Idle | Disengage | Engaged | Speaking | Fixated | Attractable | Menu | Command;
                            }
                            /**
                                * Requestion for the attention command.
                                */
                            interface AttentionRequest extends BaseCommand {
                                    Type: Commands.SetAttention;
                                    /** Mode to set Jibo's attention to. */
                                    Mode: AttentionModes.AttentionModeType;
                            }
                            /**
                                * Request for the Cancel command.
                                */
                            interface CancelRequest extends BaseCommand {
                                    Type: Commands.Cancel;
                                    ID: TransactionID;
                            }
                            /**
                                * Reponse for the Cancel command.
                                */
                            interface CancelResponse extends AcknowledgementBody {
                                    ResponseBody: string | null;
                            }
                            namespace Commands {
                                    type StartSession = 'StartSession';
                                    type GetConfig = 'GetConfig';
                                    type SetConfig = 'SetConfig';
                                    type Cancel = 'Cancel';
                                    type Display = 'Display';
                                    type SetAttention = 'SetAttention';
                                    type Say = 'Say';
                                    type Listen = 'Listen';
                                    type LookAt = 'LookAt';
                                    type TakePhoto = 'TakePhoto';
                                    type StorePhoto = 'StorePhoto';
                                    type Video = 'Video';
                                    type Subscribe = 'Subscribe';
                                    type FetchAsset = 'FetchAsset';
                                    type SkillAction = 'SkillAction';
                                    type UnloadAsset = 'UnloadAsset';
                                    type VideoPlayback = 'VideoPlayback';
                                    type CommandType = StartSession | GetConfig | SetConfig | Cancel | Display | SetAttention | Say | Listen | LookAt | TakePhoto | StorePhoto | Video | Subscribe | FetchAsset | SkillAction | UnloadAsset | VideoPlayback;
                            }
                            /**
                                * Interface for base commands.
                                */
                            interface BaseCommand {
                                    Type: Commands.CommandType;
                            }
                            /**
                                * Stream types
                                */
                            namespace Streams {
                                    type Entity = 'Entity';
                                    type HotWord = 'HotWord';
                                    type HeadTouch = 'HeadTouch';
                                    type Motion = 'Motion';
                                    type Audio = 'Audio';
                                    type ScreenGesture = 'ScreenGesture';
                                    type StreamType = Entity | HotWord | HeadTouch | Motion | ScreenGesture | Audio;
                            }
                            /**
                                * Interface for the base Subscribe command.
                                */
                            interface BaseSubscribe {
                                    Type: Commands.Subscribe;
                                    StreamType: Streams.StreamType;
                                    StreamFilter: any;
                            }
                            /**
                                * Websocket close codes
                                */
                            namespace DisconnectCodes {
                                    /** The Remote skill was exited via head touch on robot */
                                    type HeadTouchExit = 4000;
                                    /** The Remote skill was exited due to an error on the robot resulting in the error display taking over */
                                    type RobotError = 4001;
                                    /** A new Remote connection is superseding the existing one. */
                                    type NewConnection = 4002;
                                    /** The connection was closed due to inactivity (no commands sent) */
                                    type InactivityTimeout = 4003;
                                    /** Session timed out waiting for reconnect */
                                    type ReconnectTimeout = 4004;
                                    /** Session unable to wait for a reconnect */
                                    type ReconnectError = 4005;
                                    type DisconnectCodeType = HeadTouchExit | RobotError | NewConnection | InactivityTimeout | ReconnectTimeout | ReconnectError;
                            }
                            interface DisconnectReason {
                                    4000: 'Skill closed by user';
                                    4001: 'Skill closed due to robot error';
                                    4002: 'Incoming connection is replacing previous connection';
                                    4003: 'Connection closed due to inactivity';
                                    4004: 'Session closed due to reconnection time out';
                                    4005: 'Session closed due to failed reconnection';
                            }
                            /**
                                * Available display types
                                */
                            namespace DisplayViews {
                                    /** Display Jibo's eye on screen */
                                    type Eye = 'Eye';
                                    /** Display text on screen */
                                    type Text = 'Text';
                                    /** Display an image on screen */
                                    type Image = 'Image';
                                    /** Display the view finder on the screen */
                                    type ViewFinder = 'ViewFinder';
                                    /** Display an empty view on the screen */
                                    type Empty = 'Empty';
                                    type DisplayViewType = Eye | Text | Image | ViewFinder | Empty;
                            }
                            /**
                                * Ways to change display
                                */
                            namespace DisplayChanges {
                                    /** Swap the current view for another */
                                    type Swap = 'Swap';
                                    type DisplayChangeType = Swap;
                            }
                            /**
                                * Transition types
                                */
                            namespace DisplayTransitions {
                                    type DisplayTransitionType = 'Up' | 'Down' | 'In' | 'Out' | 'None';
                            }
                            type ViewType = EyeView | TextView | ImageView | ViewFinder | EmptyView;
                            interface DisplayRequest extends BaseCommand {
                                    Type: Commands.Display;
                                    View: ViewType;
                                    OpenTransition?: DisplayTransitions.DisplayTransitionType;
                                    CloseTransition?: DisplayTransitions.DisplayTransitionType;
                            }
                            interface DisplayView {
                                    /**
                                        * Type of view
                                        */
                                    Type: DisplayViews.DisplayViewType;
                                    /**
                                        * Name of view, should be unique
                                        */
                                    Name: string;
                            }
                            /**
                                * Display Jibo's eye on screen.
                                */
                            interface EyeView extends DisplayView {
                                    Type: DisplayViews.Eye;
                            }
                            /**
                                * Display an empty view on screen.
                                */
                            interface EmptyView extends DisplayView {
                                    Type: DisplayViews.Empty;
                            }
                            /**
                                * Display an image on screen.
                                * An error will be returned if that the asset is not available.
                                */
                            interface ImageView extends DisplayView {
                                    Type: DisplayViews.Image;
                                    /** An id of an asset in local cache to add to display. */
                                    Image: ImageData;
                            }
                            /**
                                * Data for a single image.
                                */
                            interface ImageData {
                                    /** Name of asset in local cache */
                                    name: string;
                                    /** URL of asset */
                                    src: string;
                                    set?: string;
                            }
                            /**
                                * Display the view finder to the screen.
                                */
                            interface ViewFinder extends DisplayView {
                                    Type: DisplayViews.ViewFinder;
                                    /** The screen space coordinates the view finder should consume */
                                    Coords: Rectangle;
                                    /** Whether or not to show the view finder */
                                    Show: boolean;
                            }
                            /**
                                * Display text on Jibo's screen.
                                */
                            interface TextView extends DisplayView {
                                    Type: DisplayViews.Text;
                                    /** Text to display. View will manage positioning and resizing of text for ideal fit */
                                    Text: string;
                            }
                            interface DisplayErrorDetails {
                                    IdNotUnique: 'View id is not unique';
                                    MissingValues: 'View was not given required values';
                                    InvalidViewType: 'View type is not valid';
                                    AssetError: 'Unable to access assets for display';
                            }
                            interface DisplayErrorResponse extends AcknowledgementBody {
                                    ErrorDetail: string;
                            }
                            /**
                                * Display events.
                                */
                            namespace DisplayEvents {
                                    type ViewStateChange = 'onViewStateChange';
                                    type DisplayEvent = ViewStateChange;
                            }
                            interface ViewStateEvent extends BaseEvent {
                                    Event: DisplayEvents.ViewStateChange;
                                    State: ViewStates.ViewStateType;
                                    View?: ViewType;
                            }
                            /**
                                * Possible view states
                                */
                            namespace ViewStates {
                                    type Opened = 'Opened';
                                    type Closed = 'Closed';
                                    type ViewStateType = Opened | Closed;
                            }
                            interface EntityRequest extends BaseSubscribe {
                                    StreamType: Streams.Entity;
                            }
                            /**
                                * Entity (face) types.
                                */
                            namespace Entities {
                                    /** Face is a loop member */
                                    type Person = 'person';
                                    /** Face is not a loop member */
                                    type Unknown = 'unknown';
                                    type EntityType = Person | Unknown;
                            }
                            /**
                                * Interface for tracking faces.
                                */
                            interface TrackedEntity {
                                    /** Unique ID of the entity being tracked */
                                    EntityID: number;
                                    /** If the face being tracked is a loop member or not */
                                    Type: Entities.EntityType;
                                    /** Jibo's confidence in his identification of the face. minimum = `0`, maximum = `1` */
                                    Confidence: number;
                                    /** Face's global location in relation to Jibo. `[x: meters forward, y: meters left, z: meters up]` */
                                    WorldCoords: Vector3;
                                    /** Face's location in relation to Jibo's screen. `[x: coord, y: coord, width, height]` */
                                    ScreenCoords: ScreenRectangle;
                            }
                            /**
                                * Entity track events.
                                */
                            namespace EntityTrackEvents {
                                    type TrackUpdate = 'onEntityUpdate';
                                    type TrackLost = 'onEntityLost';
                                    type TrackGained = 'onEntityGained';
                                    type EntityTrackEventType = TrackUpdate | TrackLost | TrackGained;
                            }
                            interface EntityTrackEvent extends BaseEvent {
                                    Event: EntityTrackEvents.EntityTrackEventType;
                                    Tracks: TrackedEntity[];
                            }
                            /**
                                * Async command events.
                                */
                            namespace AsyncCommandEvents {
                                    /** Asynchronous command has started */
                                    type Start = 'onStart';
                                    /** Asynchronous command has stopped */
                                    type Stop = 'onStop';
                                    /** An attempt to move from Requested to Start resulted in an Error */
                                    type Error = 'onError';
                                    type AsyncCommandEventType = Start | Stop | Error;
                            }
                            interface BaseEvent {
                                    Event: string;
                            }
                            interface AsyncStatusEvent extends BaseEvent {
                                    Event: AsyncCommandEvents.Start | AsyncCommandEvents.Stop;
                            }
                            interface ErrorData {
                                    /** Error code specific to the command that errored */
                                    ErrorCode: number;
                                    /** Human readable error string */
                                    ErrorString: string;
                            }
                            interface AsyncErrorEvent extends BaseEvent {
                                    Event: AsyncCommandEvents.Error;
                                    EventError: ErrorData;
                            }
                            /**
                             * play a video
                             */
                            interface VideoPlaybackRequest extends BaseCommand {
                                    Type: Commands.VideoPlayback;
                                    /**
                                        * @maxLength 1200
                                        */
                                    URI: string;
                                    /**
                                        * @maxLength 255
                                        */
                                    Name: string;
                            }
                            /**
                                * Fetches an asset
                                */
                            interface FetchAssetRequest extends BaseCommand {
                                    Type: Commands.FetchAsset;
                                    /**
                                        * @maxLength 1200
                                        */
                                    URI: string;
                                    /**
                                        * @maxLength 255
                                        */
                                    Name: string;
                            }
                            interface FetchAssetErrorDetails {
                                    OutOfMemory: 'Out of memory';
                                    InvalidURI: 'Invalid or Inaccessible URI';
                            }
                            namespace FetchAssetEvents {
                                    type AssetReady = 'onAssetReady';
                                    type AssetFailed = 'onAssetFailed';
                                    type FetchAssetEventType = AssetReady | AssetFailed;
                            }
                            interface FetchAssetEvent extends BaseEvent {
                                    Event: FetchAssetEvents.FetchAssetEventType;
                                    Detail: string;
                            }
                            interface UnloadAssetRequest extends BaseCommand {
                                    Type: Commands.UnloadAsset;
                                    Name: string;
                            }
                            interface UnloadAssetErrorDetails {
                                    InvalidName: 'Invalid or Inaccessible Name';
                            }
                            namespace UnloadAssetEvents {
                                    type UnloadAssetFailed = 'onUnloadAssetFailed';
                                    type UnloadAssetDone = 'onUnloadAssetDone';
                                    type UnloadAssetEventType = UnloadAssetFailed | UnloadAssetDone;
                            }
                            interface UnloadAssetEvent extends BaseEvent {
                                    Event: UnloadAssetEvents.UnloadAssetEventType;
                                    Detail: string;
                            }
                            /**
                                * Skill manipulation commands for skills in their own process
                                */
                            namespace SkillActions {
                                    type Show = 'Show';
                                    type Hide = 'Hide';
                                    type Kill = 'Kill';
                                    type SkillActionType = Show | Hide | Kill;
                            }
                            namespace SkillActionTransitions {
                                    type down = 'down';
                                    type scale = 'scale';
                                    type SkillActionTransitionType = down | scale;
                            }
                            interface SkillActionOptions {
                                    transition?: SkillActionTransitions.SkillActionTransitionType;
                            }
                            interface SkillActionRequest extends BaseCommand {
                                    Type: Commands.SkillAction;
                                    Action: SkillActions.SkillActionType;
                                    Options?: SkillActionOptions;
                            }
                            /**
                                * Request for GetConfig command.
                                */
                            interface GetConfigRequest extends BaseCommand {
                                    Type: Commands.GetConfig;
                            }
                            /**
                                * Battery information.
                                */
                            interface BatteryType {
                                    /** Always false. Battery is not settable */
                                    Settable: false;
                                    /** Current capacity in amphours */
                                    Capacity: number;
                                    /** Maximum battery capacity in amphours */
                                    Max_capacity: number;
                                    /** Positive number means battery is charging. Negative means it's draining */
                                    Charge_rate: number;
                            }
                            /**
                                * Wifi information.
                                */
                            interface WifiType {
                                    /** WiFi strength */
                                    Strength: number;
                                    Settable: false;
                            }
                            /**
                                * Mixers information.
                                */
                            interface MixersType {
                                    /** Master volume from 0 (mute) to 1 (loudest) */
                                    Master: number;
                                    /** `false` to prohibit setting the volume. */
                                    Settable: boolean;
                            }
                            /**
                                * Position information.
                                */
                            interface PositionType {
                                    /** Jibo's global position */
                                    WorldPosition: Vector3;
                                    /** Jibo's angular twist position */
                                    AnglePosition: AngleVector;
                            }
                            namespace ConfigEvents {
                                    type onConfig = 'onConfig';
                                    type ConfigEventType = onConfig;
                            }
                            interface ConfigEvent extends BaseEvent {
                                    Event: ConfigEvents.ConfigEventType;
                                    Battery: BatteryType;
                                    Wifi: WifiType;
                                    Position: PositionType;
                                    Mixers: MixersType;
                            }
                            /**
                                * 128bit hexidecimal number that must be unique every transaction issued by the particular ROM
                                * Server.  The Command Library supplied by Jibo does a 128 bit hash on the Server IP address and
                                * the current time.  Because this is a hash this ID cannot be treated as a sequence number for
                                * Command serialization. Must be 32 characters long
                                * @minLength 32
                                * @maxLength 32
                                */
                            type TransactionID = string;
                            interface RequestHeader {
                                    /**
                                        * The reverse domain assigned name for the application provided by
                                        * Jibo to the application developer. For example the remote control appID is
                                        * `com.jibo.app.remotecontrol`.
                                        */
                                    AppID: string;
                                    /**
                                        * The session identifier that was assigned for this connection
                                        * between the Server and Controller. Is only allowed to be null for a `StartSession` command.
                                        */
                                    SessionID: string | null;
                                    /**
                                        * Not in use
                                        */
                                    Credentials: any;
                                    /**
                                        * This is the version that is required on the robot in order to handle the request.
                                        * Requesting a Protocol version that is greater than the supported version on the Robot is an
                                        * error.
                                        */
                                    Version: string;
                                    /**
                                        * Unique identifier for the transaction
                                        */
                                    TransactionID: TransactionID;
                            }
                            interface ResponseHeader {
                                    /**
                                        * @pattern ^[a-z]{3,15}-[a-z]{3,15}-[a-z]{3,15}-[a-z]{3,15}$
                                        */
                                    RobotID: string;
                                    /** The session identifier that was assigned for this connection between the Server and Controller. */
                                    SessionID: string;
                                    TransactionID: TransactionID;
                            }
                            interface EventHeader extends ResponseHeader {
                                    /**
                                        * `unsigned[9].unsigned[2]` (ex: `987456354.24`).
                                        * UTC time since the UNIX epoch when this event occurred measured on the robot.
                                        */
                                    Timestamp: number;
                            }
                            interface HeadTouchRequest extends BaseSubscribe {
                                    StreamType: Streams.HeadTouch;
                            }
                            /**
                                * headtouch events.
                                */
                            namespace HeadTouchEvents {
                                    type HeadTouched = 'onHeadTouch';
                            }
                            interface HeadTouchEvent extends BaseEvent {
                                    Event: HeadTouchEvents.HeadTouched;
                                    /**
                                        * contains the state of the
                                        * head sensors, in this order: left front, left middle, left back, right front,
                                        * right middle, right back, from the robot's point of view.
                                        */
                                    Pads: [boolean, boolean, boolean, boolean, boolean, boolean];
                            }
                            /**
                                * Headtouch pads for increased ease of use.
                                * Refers to Jibo's left and right, not the users.
                                */
                            namespace HeadTouchPads {
                                    type FrontLeft = 0;
                                    type MiddleLeft = 1;
                                    type BackLeft = 2;
                                    type FrontRight = 3;
                                    type MiddleRight = 4;
                                    type BackRight = 5;
                            }
                            interface HotWordRequest extends BaseSubscribe {
                                    StreamType: Streams.HotWord;
                                    Listen: boolean;
                            }
                            /**
                                * Speech events.
                                */
                            namespace HotWordEvents {
                                    type HotWordHeard = 'onHotWordHeard';
                                    type ListenResult = 'onListenResult';
                            }
                            interface Speaker {
                                    /** Position of speaker */
                                    LPSPosition: LPSPosition;
                                    /** Who is speaking */
                                    SpeakerID: SpeakerId;
                            }
                            interface LPSPosition {
                                    /** global position */
                                    Position: Vector3;
                                    /** 2D twist position */
                                    AngleVector: Vector2;
                                    /** `[0,1]` How confident Jibo is in his identification. */
                                    Confidence: number;
                            }
                            interface SpeakerId {
                                    Type: Entities.EntityType;
                                    /** `[0,1]` How confident Jibo is in his identification. */
                                    Confidence: number;
                            }
                            interface HotWordHeardEvent extends BaseEvent {
                                    Event: HotWordEvents.HotWordHeard;
                                    Speaker: Speaker;
                            }
                            interface HotWordListenResultEvent extends BaseEvent {
                                    Event: HotWordEvents.ListenResult;
                                    Result: string;
                            }
                            type AllCommands = BaseCommands | RobotCommands;
                            type BaseCommands = SessionRequest | CancelRequest;
                            type RobotCommands = GetConfigRequest | AttentionRequest | SayRequest | ListenRequest | LookAtRequest | TakePhotoRequest | StorePhotoRequest | VideoRequest | EntityRequest | HotWordRequest | ScreenGestureRequest | DisplayRequest | MotionRequest | AudioRequest | SetConfigRequest | HeadTouchRequest | FetchAssetRequest | SkillActionRequest | UnloadAssetRequest | VideoPlaybackRequest;
                            /**
                                * Base command for all protocol messages
                                */
                            interface Command {
                                    ClientHeader: RequestHeader;
                                    Command: AllCommands;
                            }
                            type AllAcknowlegements = AcknowledgementBody | SessionResponse | CancelResponse | ListenErrorResponse | LookAtErrorResponse | UnloadAssetResponse;
                            interface Acknowledgement {
                                    ResponseHeader: ResponseHeader;
                                    Response: AllAcknowlegements;
                            }
                            type AllEvents = AsyncStatusEvent | AsyncErrorEvent | ListenStopEvent | ViewStateEvent | LookAtAchievedEvent | LookAtTrackLostEvent | TakePhotoEvent | StorePhotoEvent | VideoReadyEvent | EntityTrackEvent | HotWordHeardEvent | HotWordListenResultEvent | TapEvent | SwipeEvent | HeadTouchEvent | FetchAssetEvent | ListenResultEvent | MotionEvent | ConfigEvent | AudioEvent | UnloadAssetEvent;
                            interface EventMessage {
                                    EventHeader: EventHeader;
                                    EventBody: AllEvents;
                            }
                            namespace ProtocolVersions {
                                    type v1 = JIBO.ProtocolVersions.v1;
                                    type v2 = JIBO.ProtocolVersions.v2;
                                    type ProtocolVersionType = JIBO.ProtocolVersions.ProtocolVersionType;
                            }
                            type AllViews = EyeView | TextView | ImageView | ViewFinder | EmptyView;
                            type AllResponses = Acknowledgement | EventMessage;
                            interface ListenRequest extends BaseCommand {
                                    Type: Commands.Listen;
                                    /**
                                        * Number of milliseconds (ms) of speech that will be accepted until it is terminated.
                                        * Note there is a 15 second built in limit.
                                        */
                                    MaxSpeechTimeout?: number;
                                    /**
                                        * maximum 15 seconds
                                        */
                                    MaxNoSpeechTimeout?: number;
                                    /**
                                        * `<2 char language code>-<2 char country code>` or just the language code.
                                        * @pattern ^[a-z]{2}$|^[a-z]{2}-[A-Z]{2}$
                                        */
                                    LanguageCode?: string;
                            }
                            interface ListenErrorDetails {
                                    NoLanguage: 'Language not supported';
                                    ListenConflict: 'Listen already executing';
                                    HJListenConflict: 'HJ Listen already executing';
                            }
                            interface ListenErrorResponse extends AcknowledgementBody {
                                    ErrorDetail: string;
                            }
                            /**
                                * Listen events.
                                */
                            namespace ListenEvents {
                                    type ListenResult = 'onListenResult';
                            }
                            namespace ListenStopReasons {
                                    type NoInput = 'NoInput';
                                    type NoMatch = 'NoMatch';
                                    type Interrupted = 'Interrupted';
                                    type ListenStopReasonType = NoInput | NoMatch | Interrupted;
                            }
                            interface ListenStopEvent extends BaseEvent {
                                    Event: AsyncCommandEvents.Stop;
                                    StopReason: ListenStopReasons.ListenStopReasonType;
                            }
                            interface ListenResultEvent extends BaseEvent {
                                    Event: ListenEvents.ListenResult;
                                    /**
                                        * @pattern ^[a-z]{2}$|^[a-z]{2}-[A-Z]{2}$
                                        */
                                    LanguageCode?: string;
                                    Speech: string;
                            }
                            /**
                                * Integer representing the entity (face) to look at.
                                */
                            type LookAtEntity = number;
                            /**
                                * `[x: meters forward, y: meters left, z: meters up]`
                                */
                            interface PositionTarget {
                                    /** Vector that provides a location in space in the base coordinate frame of the robot to look at. */
                                    Position: Vector3;
                            }
                            /**
                                * `[theta: twist/horizontal angle, psi: vertical angle]`
                                */
                            interface AngleTarget {
                                    /**
                                        * These angles are relative to Jibo's current orientation
                                        * vector that provides a twist angle (theta) and vertical angle (psi) in
                                        * the base coordinate from of the robot to look at.
                                        */
                                    Angle: AngleVector;
                            }
                            /**
                                * Targeting a face. Currently unsupported.
                                */
                            interface EntityTarget {
                                    /**
                                        * An integer that refers to an entity that is known and available in Jibo’s LPS
                                        * system. An error will be returned if that entity is no longer being tracked.
                                        */
                                    Entity: LookAtEntity;
                            }
                            interface CameraTarget {
                                    ScreenCoords: Vector2;
                                    ScreenSize?: Vector2;
                            }
                            /**
                                * What type of target to look toward.
                                */
                            type LookAtTarget = PositionTarget | AngleTarget | EntityTarget | CameraTarget;
                            interface LookAtRequest extends BaseCommand {
                                    Type: Commands.LookAt;
                                    LookAtTarget: LookAtTarget | undefined;
                                    /**
                                        * If `true`, Jibo will track the desired target. Note that for a position or angle
                                        * target this will just hold Jibo steady.
                                        */
                                    TrackFlag: boolean;
                                    /**
                                        * If `true`, Jibo will go to the closest possible kinematic
                                        * position to the requested position while requiring the display remain level. If `false`,
                                        * Jibo will go to the exact requested position, but the head may not be level.
                                        */
                                    LevelHeadFlag?: boolean;
                            }
                            interface LookAtErrorDetails {
                                    InvalidAngle: 'LookAt location is not valid';
                                    InvalidEntity: 'Invalid or unavailable Entity';
                            }
                            interface LookAtErrorResponse extends AcknowledgementBody {
                                    ErrorDetail: string;
                            }
                            namespace LookAtEvents {
                                    type LookAtAchieved = 'onLookAtAchieved';
                                    type TrackEntityLost = 'onTrackEntityLost';
                                    type LookAtEventType = LookAtAchieved | TrackEntityLost;
                            }
                            /**
                                * Returns the location that was achieved in both absolute space and angle space.
                                */
                            interface LookAtAchievedEvent extends BaseEvent {
                                    Event: LookAtEvents.LookAtAchieved;
                                    PositionTarget: Vector3;
                                    AngleTarget: AngleVector;
                            }
                            /**
                                * Returns the entity that was lost and current position when it was lost. Only applies to requests
                                * for Entities not positions or angles.
                                */
                            interface LookAtTrackLostEvent extends BaseEvent {
                                    Event: LookAtEvents.TrackEntityLost;
                                    EntityTarget: LookAtEntity;
                                    PositionTarget: Vector3;
                                    AngleTarget: AngleVector;
                            }
                            interface UnloadAssetResponse extends AcknowledgementBody {
                                    ErrorDetail: string;
                            }
                            type Vector3 = [number, number, number];
                            type Vector2 = [number, number];
                            /**
                                * `[theta, psi]` where `theta` = twist/horizontal angle and `psi` = vertical angle.
                                */
                            type AngleVector = [number, number];
                            /**
                                * `[x, y, width, height]`
                                */
                            type ScreenRectangle = [number, number, number, number];
                            interface MotionRequest extends BaseSubscribe {
                                    StreamType: Streams.Motion;
                            }
                            /**
                                * Information for tracking motion.
                                */
                            interface MotionEntity {
                                    /** Speed of motion. minimum = `0`, maximum = `1` */
                                    Intensity: number;
                                    /** 3D global location of motion. */
                                    WorldCoords: Vector3;
                                    /** 2D location of motion in relation to Jibo's screen. */
                                    ScreenCoords: ScreenRectangle;
                            }
                            /**
                                * motion track events.
                                */
                            namespace MotionEvents {
                                    type MotionDetected = 'onMotionDetected';
                            }
                            interface MotionEvent extends BaseEvent {
                                    Event: MotionEvents.MotionDetected;
                                    Motions: MotionEntity[];
                            }
                            interface AudioRequest extends BaseSubscribe {
                                    StreamType: Streams.Audio;
                            }
                            /**
                                * For audio events
                                */
                            interface AudioEntity {
                                    Intensity: number;
                                    WorldCoords: Vector3;
                                    LookDirection: {
                                            Pos: Vector3;
                                            Dir: Vector3;
                                    };
                            }
                            namespace AudioEvents {
                                    type AudioDetected = 'onAudioDetected';
                            }
                            interface AudioEvent extends BaseEvent {
                                    Event: AudioEvents.AudioDetected;
                                    Audio: AudioEntity;
                            }
                            interface SpeakOptions {
                                    disableAutoRules?: boolean;
                                    followedByListen?: boolean;
                                    centeringEnabled?: boolean;
                            }
                            interface AutoRuleConfig {
                                    hotWords?: boolean;
                                    punctuation?: boolean;
                                    voice?: boolean;
                                    beat?: boolean;
                            }
                            interface SayRequest extends BaseCommand {
                                    Type: Commands.Say;
                                    /**  maxLength 1200 */
                                    ESML: string;
                                    AutoRuleConfig?: AutoRuleConfig;
                                    SpeakOptions?: SpeakOptions;
                            }
                            interface SayErrorDetails {
                                    BadESML: 'ESML is not valid';
                                    InvalidURI: 'Invalid or Inaccessible URI';
                            }
                            interface ScreenGestureRequest extends BaseSubscribe {
                                    StreamType: Streams.ScreenGesture;
                                    StreamFilter: ScreenGestureFilter;
                            }
                            interface ScreenGestureFilter {
                                    Type?: ScreenGestures.ScreenGestureType;
                                    Area?: Rectangle | Circle;
                            }
                            /**
                                * Available gesture types.
                                */
                            namespace ScreenGestures {
                                    type Tap = 'Tap';
                                    type SwipeDown = 'SwipeDown';
                                    type SwipeUp = 'SwipeUp';
                                    type SwipeRight = 'SwipeRight';
                                    type SwipeLeft = 'SwipeLeft';
                                    type ScreenGestureType = Tap | SwipeDown | SwipeUp | SwipeRight | SwipeLeft;
                            }
                            /**
                                * Define a rectangular area on Jibo's screen.
                                */
                            interface Rectangle {
                                    /** Horizontal coordinate of upper-left corner */
                                    x: number;
                                    /** Vertical coordinate of upper-left corner */
                                    y: number;
                                    /** Pixels wide from x */
                                    width: number;
                                    /** Pixels high down from y */
                                    height: number;
                            }
                            /**
                                * Define a circular area on Jibo's screen
                                */
                            interface Circle {
                                    /** Horizontal coordinate of circle center */
                                    x: number;
                                    /** Vertical coordinate of circle center */
                                    y: number;
                                    /** Circle radius from `[x,y]` */
                                    radius: number;
                            }
                            /**
                                * Enum of screen gesture events.
                                */
                            namespace ScreenGestureEvents {
                                    type Tap = 'onTap';
                                    type Swipe = 'onSwipe';
                                    type ScreenGestureEvent = Tap | Swipe;
                            }
                            interface TapEvent extends BaseEvent {
                                    Event: ScreenGestureEvents.Tap;
                                    Coordinate: Vector2;
                            }
                            interface SwipeEvent extends BaseEvent {
                                    Event: ScreenGestureEvents.Swipe;
                                    Direction: SwipeDirections.SwipeDirectionType;
                            }
                            /**
                                * Available swipe directions.
                                */
                            namespace SwipeDirections {
                                    type Up = 'Up';
                                    type Down = 'Down';
                                    type Right = 'Right';
                                    type Left = 'Left';
                                    type SwipeDirectionType = Up | Down | Right | Left;
                            }
                            interface SessionRequest extends BaseCommand {
                                    Type: Commands.StartSession;
                            }
                            interface SessionInfo {
                                    SessionID: string;
                                    /**
                                        * @pattern ^\d+\.\d+$
                                        */
                                    Version: string;
                            }
                            interface SessionResponse extends AcknowledgementBody {
                                    Value: 'Success';
                                    ResponseCode: ResponseCodes.OK;
                                    ResponseBody: SessionInfo;
                            }
                            /**
                                * Battery information.
                                */
                            interface SetConfigOptions {
                                    /** Master volume from 0 (mute) to 1 (max) */
                                    Mixer: number;
                            }
                            interface SetConfigRequest extends BaseCommand {
                                    Type: Commands.SetConfig;
                                    Options: SetConfigOptions;
                            }
                            /**
                                * Camera options.
                                */
                            namespace Cameras {
                                    /** default */
                                    type Left = 'left';
                                    /** unsupported */
                                    type Right = 'right';
                                    type CameraType = Left | Right;
                            }
                            /**
                                * Camera resolutions
                                */
                            namespace CameraResolutions {
                                    /** Currently unsupported */
                                    type HighRes = 'highRes';
                                    /** Higher res than default */
                                    type MedRes = 'medRes';
                                    /** Default */
                                    type LowRes = 'lowRes';
                                    /** Lower res than default */
                                    type MicroRes = 'microRes';
                                    type CameraResolutionType = HighRes | MedRes | LowRes | MicroRes;
                            }
                            interface TakePhotoRequest extends BaseCommand {
                                    Type: Commands.TakePhoto;
                                    Camera: Cameras.CameraType;
                                    Resolution: CameraResolutions.CameraResolutionType;
                                    Distortion?: boolean;
                            }
                            interface StorePhotoRequest extends BaseCommand {
                                    Type: Commands.StorePhoto;
                                    Id: string;
                            }
                            /**
                                * TakePhoto events.
                                */
                            namespace PhotoEvents {
                                    type TakePhoto = 'onTakePhoto';
                            }
                            interface TakePhotoEvent extends BaseEvent {
                                    Event: PhotoEvents.TakePhoto;
                                    /**
                                        * URI location on the robot that the photo was stored.
                                        * This is a global URI that can be used with an HTTP GET to fetch the asset.
                                        */
                                    URI: string;
                                    /**
                                        * The id given to the photo by the media service. Can be
                                        * used to store the photo from being in-memory to being
                                        * on-disk in the gallery.
                                        */
                                    Id?: string;
                                    /**
                                        * The name parameter is a local handle on the Robot which can be
                                        * used in PutAsset to put the image into the Gallery.
                                        */
                                    Name: string;
                                    PositionTarget: Vector3;
                                    AngleTarget: AngleVector;
                            }
                            /**
                                * StorePhoto events.
                                */
                            namespace PhotoEvents {
                                    type StorePhoto = 'onStorePhoto';
                            }
                            interface StorePhotoEvent extends BaseEvent {
                                    Event: PhotoEvents.StorePhoto;
                                    /**
                                        * The id of the stored photo.
                                        */
                                    Id: string;
                            }
                            /**
                                * video types
                                */
                            namespace Videos {
                                    /** Default */
                                    type Normal = 'NORMAL';
                                    /** Currently unsupported */
                                    type Debug = 'DEBUG';
                                    type VideoType = Normal | Debug;
                            }
                            interface VideoRequest extends BaseCommand {
                                    Type: Commands.Video;
                                    Duration?: number;
                                    VideoType?: Videos.VideoType;
                            }
                            /**
                                * Video events
                                */
                            namespace VideoEvents {
                                    type VideoReady = 'onVideoReady';
                            }
                            interface VideoReadyEvent extends BaseEvent {
                                    Event: VideoEvents.VideoReady;
                                    /** Location at which the video stream can be connected to via GET request. */
                                    URI: string;
                            }
                    }
                    /**
                        * The v2 protocol. This will be used by Pegasus and Phoenix skills
                        */
                    namespace v2 {
                            namespace math {
                                    interface Vector2 {
                                            x: number;
                                            y: number;
                                    }
                                    interface Vector3 extends Vector2 {
                                            z: number;
                                    }
                            }
                            namespace commands {
                                    /**
                                        * BaseCommand base interface. Every command has a unique `transationId`,
                                        * referred to in behavior tree events and responses.
                                        */
                                    interface BaseCommand<T extends CommandTypes> {
                                            header: {
                                                    type: T;
                                                    /** A UUID */
                                                    transactionId: string;
                                            };
                                    }
                                    /**
                                        * If a command executed successfully, the command response will always
                                        * contain this response code, along with any other data pertinent to that
                                        * command. There is only one SuccessCodeResponse
                                        */
                                    type ACCEPTED = 202;
                                    type SuccessCodeType = ACCEPTED;
                                    /**
                                     * Badly formatted JSON. There was a syntax error
                                     * in the JSON sent over the wire.
                                     */
                                    type BAD_REQUEST = 400;
                                    /**
                                        * This command is not allowed for this skill. See [[ACO]].
                                        */
                                    type FORBIDDEN = 403;
                                    /**
                                        * This command is not found, or the asset was not found.
                                        */
                                    type NOT_FOUND = 404;
                                    /**
                                        * Well formed json, but the schema is bad
                                        */
                                    type NOT_ACCEPTABLE = 406;
                                    /**
                                        * This request took too long
                                        */
                                    type REQUEST_TIMEOUT = 407;
                                    /**
                                        * A precondition was not met for this method. For example,
                                        * trying to send a command before called [[StartSession]], or
                                        * trying to stop a behavior tree that does not exist
                                        */
                                    type PRECONDITION_FAILED = 412;
                                    /**
                                        * The particular service is unavailable or not responding
                                        */
                                    type SERVICE_UNAVAILABLE = 503;
                                    /**
                                        * Only used in response to a [[StartSession]] if a client
                                        * requests a version that is not supported.
                                        */
                                    type VERSION_NOT_SUPPORTED = 505;
                                    /**
                                     * The typical responses for any command except [[StartSession]].
                                     */
                                    type ErrorCodeType = BAD_REQUEST | FORBIDDEN | NOT_FOUND | NOT_ACCEPTABLE | REQUEST_TIMEOUT | PRECONDITION_FAILED | SERVICE_UNAVAILABLE;
                                    type VersionNotSupportedType = VERSION_NOT_SUPPORTED;
                                    /**
                                        * All response codes
                                        */
                                    type ResponseCodeType = ErrorCodeType | SuccessCodeType | VersionNotSupportedType;
                                    /** Response base class */
                                    interface BaseResponse<T extends ResponseCodeType> {
                                            header: {
                                                    transactionId: string;
                                                    code: T;
                                            };
                                    }
                                    /**
                                        * Base interface for all error responses.
                                        * All error responses have a message field with
                                        * a human understandable description of the error.
                                        */
                                    interface ErrorResponse extends BaseResponse<ErrorCodeType> {
                                            message: string;
                                    }
                                    interface VersionNotSupported extends BaseResponse<VERSION_NOT_SUPPORTED> {
                                            message: string;
                                            /** this is the highest version supported */
                                            version: string;
                                    }
                                    interface DefaultResponse extends BaseResponse<SuccessCodeType | ErrorCodeType> {
                                    }
                                    type CommandTypes = "START_SESSION" | "STOP_SESSION" | "START_BEHAVIOR_TREE" | "STOP_BEHAVIOR_TREE" | "SCHEDULE_BEHAVIOR_TREE" | "UNSCHEDULE_BEHAVIOR_TREE" | "GET_SCHEDULED_BEHAVIOR_TREES" | "SUBSCRIBE" | "UNSUBSCRIBE" | "FETCH_ASSET" | "PUT_ASSET" | "GET_USED_RESOURCES" | "SET_CONFIG" | "GET_CONFIG" | "UNLOAD_ASSET";
                                    /**
                                        * Starts a new session. Must be called first.
                                        */
                                    interface StartSession extends BaseCommand<"START_SESSION"> {
                                            sessionId: string;
                                            sourceId: string;
                                            version: string;
                                    }
                                    type StartSessionResponse = DefaultResponse | VersionNotSupported;
                                    /**
                                        * Stops a session. Kills the skill and brings Jibo back to idle
                                        */
                                    interface StopSession extends BaseCommand<"STOP_SESSION"> {
                                    }
                                    type StopSessionResponse = DefaultResponse;
                                    /**
                                        * Start a behavior tree
                                        */
                                    interface StartBehaviorTree extends BaseCommand<"START_BEHAVIOR_TREE"> {
                                            /** The root behavior */
                                            behavior: behaviors.Behavior;
                                            /** A set of key value pairs to initialize the blackboard */
                                            blackboard?: any;
                                    }
                                    type StartBehaviorTreeResponse = DefaultResponse;
                                    /**
                                        * Command to stop a behavior tree
                                        */
                                    interface StopBehaviorTree extends BaseCommand<"STOP_BEHAVIOR_TREE"> {
                                            /** Transaction id that started the behavior tree */
                                            transactionId: string;
                                    }
                                    type StopBehaviorTreeResponse = DefaultResponse;
                                    /** Scheduled condition types */
                                    type ScheduledConditionType = "TIME" | "ID";
                                    /** The base interface for a condition to execute the behavior tree */
                                    interface ScheduledCondition {
                                            type: ScheduledConditionType;
                                            /** Can be any unique or non-unique string */
                                            name: string;
                                    }
                                    /**
                                        * A Time based condition for execution
                                        */
                                    interface ScheduledTimeCondition extends ScheduledCondition {
                                            type: "TIME";
                                            /** Unix epoch that determines when to execute a behavior tree */
                                            time: number;
                                    }
                                    /**
                                        * A person ID based condition to execute a behavior tree
                                        */
                                    interface ScheduledIDCondition extends ScheduledCondition {
                                            type: "ID";
                                            loopMemberId: string;
                                    }
                                    /**
                                        * Set a scheduled execution plan
                                        */
                                    interface ScheduleBehaviorTree extends BaseCommand<"SCHEDULE_BEHAVIOR_TREE"> {
                                            /** The beehavior tree to execute */
                                            behavior: behaviors.Behavior;
                                            /** Blackboard initialization */
                                            blackboard?: any;
                                            /** The condition that triggers the execution of this behavior tree */
                                            condition: ScheduledTimeCondition | ScheduledIDCondition;
                                            /** How long to keep this around in the scheduler */
                                            timeout?: number;
                                            /** An arbitrary data blob to store with this behavior tree */
                                            data: any;
                                    }
                                    type ScheduleBehaviorTreeResponse = DefaultResponse;
                                    /**
                                        * Cancel a scheduled execution plan
                                        */
                                    interface UnscheduleBehaviorTree extends BaseCommand<"UNSCHEDULE_BEHAVIOR_TREE"> {
                                            transactionId: string;
                                    }
                                    type UnscheduleBehaviorTreeResponse = DefaultResponse;
                                    /** Data that represents a scheduled tree
                                        *
                                        * `ScheduledCondition & `
                                        *
                                        * `{data:any} & //Data sent along with the command`
                                        *
                                        * `{transactionId:string} //The transactionId of the ScheduleBehaviorTree command`
                                        */
                                    interface ScheduledTrees extends ScheduledCondition {
                                            data: any;
                                            transactionId: string;
                                    }
                                    /**
                                        * Get all scheduled execution plans
                                        */
                                    interface GetScheduledBehaviorTreesCommand extends BaseCommand<"GET_SCHEDULED_BEHAVIOR_TREES"> {
                                            transactionIds?: string[];
                                    }
                                    interface GetScheduleBehaviorTreeAcceptedResponse extends BaseResponse<ACCEPTED> {
                                            /** An array of all scheduled behavior trees */
                                            scheduledTrees: ScheduledTrees[];
                                    }
                                    type GetScheduleBehaviorTreeResponse = GetScheduleBehaviorTreeAcceptedResponse | ErrorResponse;
                                    /**
                                        * Returns the resources being used by all behavior trees
                                        * currently running
                                        */
                                    interface GetUsedResources extends BaseCommand<"GET_USED_RESOURCES"> {
                                    }
                                    type GetUsedResourcesResponse = GetUsedResourcesAcceptedResponse | ErrorResponse;
                                    /**
                                        * Response to [[GetUsedResources]] command
                                        */
                                    interface GetUsedResourcesAcceptedResponse extends BaseResponse<ACCEPTED> {
                                            /**
                                                * `resources:{ type, user | user[] }[]` //The currently used resources
                                                *
                                                * `type:`[[ResourceType]]` //The resource type
                                                *
                                                * `user:{ behaviorTransactionId:string, behaviorName:string }` //Who is using
                                                * this resource. Can be a single entity, or multiple entities for resources
                                                * that can be shared.
                                                */
                                            resources: {
                                                    /** The resource type */
                                                    type: resources.ResourceType;
                                                    /**
                                                        * Who is using this resource. Can be a single entity,
                                                        * or multiple entities for resources that can be shared.
                                                        */
                                                    user: {
                                                            /**
                                                                * The transactionId of the [[StartBehaviorTree]] command that
                                                                * started this tree
                                                                */
                                                            transactionId: string;
                                                            /** The name of the behavior using this resource */
                                                            behaviorName: string;
                                                    } | {
                                                            transactionId: string;
                                                            behaviorName: string;
                                                    }[];
                                            }[];
                                    }
                                    /**
                                        * Fetch assets
                                        */
                                    interface FetchAssetCommand extends BaseCommand<"FETCH_ASSET"> {
                                            uri: string;
                                            name: string;
                                    }
                                    type FetchAssetResponse = DefaultResponse;
                                    /**
                                        * Unload assets
                                        */
                                    interface UnloadAssetCommand extends BaseCommand<"UNLOAD_ASSET"> {
                                            name: string;
                                    }
                                    type UnloadAssetResponse = DefaultResponse;
                                    /**
                                        * Put asset
                                        */
                                    interface PutAssetCommand extends BaseCommand<"PUT_ASSET"> {
                                            /**
                                                * `{uri:string} | {name:string, set:"robot.GALLERY" | string}`
                                                *
                                                * Cannot use robot.* pattern in a set
                                                */
                                            asset: {
                                                    uri: string;
                                            } | {
                                                    name: string;
                                                    set: "robot.GALLERY" | string;
                                            };
                                    }
                                    type PutAssetResponse = DefaultResponse;
                                    /**
                                        * Set robot configuration
                                        */
                                    interface SetConfig extends BaseCommand<"SET_CONFIG"> {
                                            mixer?: {
                                                    master: number;
                                            };
                                    }
                                    type SetConfigResponse = DefaultResponse;
                                    /**
                                        * Get robot configurations
                                        */
                                    interface GetConfig extends BaseCommand<"GET_CONFIG"> {
                                    }
                                    type GetConfigResponse = ErrorResponse | GetConfigAcceptedResponse;
                                    /**
                                        * See [[GetConfig]]
                                        */
                                    interface GetConfigAcceptedResponse extends BaseResponse<ACCEPTED> {
                                            /** Battery information */
                                            battery: {
                                                    settable: false;
                                                    /** Battery's current capacity in mAh */
                                                    capacity: number;
                                                    /** Represented as C-rate */
                                                    chargeRate: number;
                                                    /** Battery's max capacity in mAh */
                                                    maxCapacity: number;
                                            };
                                            wifi: {
                                                    settable: false;
                                                    /** Wifi signal strength */
                                                    strength: number;
                                            };
                                            /** Volume controls */
                                            mixers: {
                                                    settable: true;
                                                    /** Master volume between [0,1] */
                                                    master: number;
                                            };
                                            /** Robot's current look position */
                                            position: {
                                                    worldPosition: math.Vector3;
                                                    anglePosition: math.Vector2;
                                            };
                                    }
                                    /**
                                        * Subscribes to a set of events defined by the event filters array
                                        */
                                    interface Subscribe extends BaseCommand<"SUBSCRIBE"> {
                                            /** An array of filters */
                                            filters: filters.EventFilter[];
                                    }
                                    type SubscribeResponse = DefaultResponse;
                                    /**
                                        * Unsubscribes from a set of event filters
                                        * TODO -> unsubscribe all
                                        */
                                    interface Unsubscribe extends BaseCommand<"UNSUBSCRIBE"> {
                                            /** The transationId of the command */
                                            transactionId: string;
                                    }
                                    type UnsubscribeResponse = DefaultResponse;
                            }
                            namespace filters {
                                    type EventFilterType = "IMAGE_FILTER" | "AUDIO_FILTER" | "SPEECH_FILTER" | "SCREEN_TOUCH_FILTER" | "HEAD_TOUCH_FILTER" | "HEAD_HOLD_FILTER" | "ENTITY_FILTER";
                                    interface BaseEventFilter {
                                            type: EventFilterType;
                                    }
                                    interface ImageFilter extends BaseEventFilter {
                                            type: "IMAGE_FILTER";
                                            resolution: "FULL" | "PREVIEW";
                                            camera: "LEFT" | "RIGHT";
                                            /**
                                                * This is the target rate and the maximum rate at
                                                * which images will be delivered in images per second.
                                                * There is an absolute maximum of 15 images in a second for RCP 1.0.
                                                */
                                            maxRate: number;
                                    }
                                    interface SpeechFilter extends BaseEventFilter {
                                            type: "SPEECH_FILTER";
                                            /** `{confidence:number, type: "PERSON"|"UNKNOWN"}[]` */
                                            entityFilters: {
                                                    confidence: number;
                                                    type: "PERSON" | "UNKNOWN";
                                            }[];
                                    }
                                    type ScreenGestureType = "SWIPE" | "SWIPEDOWN" | "SWIPELEFT" | "SWIPERIGHT";
                                    interface ScreenTouchFilter extends BaseEventFilter {
                                            type: "SCREEN_TOUCH_FILTER";
                                            /** If not specified, the entire screen area is valid.
                                                *
                                                * `{x:number, y:number, width:number, height:number}` |
                                                *
                                                * `{x:number, y:number, radius:number};`
                                                */
                                            area?: {
                                                    x: number;
                                                    y: number;
                                                    width: number;
                                                    height: number;
                                            } | {
                                                    x: number;
                                                    y: number;
                                                    radius: number;
                                            };
                                            gestures?: ScreenGestureType[];
                                    }
                                    /** For now there are no gesture types. Just head touch */
                                    interface HeadTouchFilter extends BaseEventFilter {
                                            type: "HEAD_TOUCH_FILTER";
                                    }
                                    /** For now there are no gesture types. Just head touch */
                                    interface HeadHoldFilter extends BaseEventFilter {
                                            type: "HEAD_HOLD_FILTER";
                                    }
                                    type DetectType = "MOTION" | "DETECT" | "TRACK" | "ENTITY";
                                    type EntityType = "PERSON" | "UNKNOWN";
                                    interface EntityFilter extends BaseEventFilter {
                                            type: "ENTITY_FILTER";
                                            detectType: DetectType;
                                            entityType: "UNKNOWN";
                                    }
                                    interface PersonEntityFilter extends BaseEventFilter {
                                            type: "ENTITY_FILTER";
                                            detectType: "ENTITY";
                                            entityType: "PERSON";
                                            /**
                                                * Array of loop member ids. If none are defined, doesn't
                                                * filter anyone
                                                */
                                            entityIds?: string[];
                                            /** Confidence threshold */
                                            confidence: number;
                                    }
                                    /** This describes the event filter type */
                                    type EventFilter = ImageFilter | SpeechFilter | ScreenTouchFilter | HeadTouchFilter | HeadHoldFilter | EntityFilter | PersonEntityFilter;
                            }
                            namespace behaviors {
                                    /**
                                        * Structural behavior types
                                        */
                                    type BaseBehaviorType = "PARALLEL" | "SEQUENCE" | "SELECT" | "NULL";
                                    /**
                                        * All decorator types
                                        */
                                    type DecoratorType = "REPEAT" | "SUCCEED" | "FAIL" | "TIMEOUT" | "START_ON_FINISHED_ORIENT";
                                    /**
                                        * Describes behaviors
                                        * skills must have permission to perform
                                        */
                                    type RobotBehaviorType = "DISPLAY" | "LISTEN" | "PLAY" | "LOOKAT" | "PLAY_ANIMATION" | "FETCH_ASSET" | "PUT_ASSET" | "TAKE_PHOTO" | "HEAD_TOUCH" | "VIEWFINDER" | "SLIM" | "UNLOAD_ASSET" | "SET_PRESENT_PERSON" | "IMPACT_EMOTION";
                                    type BehaviorType = DecoratorType | RobotBehaviorType | BaseBehaviorType;
                                    /**
                                        * The base behavior type. Every behavior has a unique `id`
                                        * and defines a behavior type. See [[BehaviorType]].
                                        */
                                    interface Behavior {
                                            /** A uuid generated by the client */
                                            id: string;
                                            /** Defines the type of behavior this is */
                                            type: BehaviorType;
                                            /** Optional field containing any metadata we want to send along with the behavior */
                                            meta?: any;
                                    }
                                    /**
                                        * The decorator type.
                                        */
                                    interface Decorator extends Behavior {
                                            /** The behavior this decorates */
                                            child: Behavior;
                                    }
                                    /**
                                        * The base interface for all parent behaviors
                                        */
                                    interface ParentBehavior extends Behavior {
                                            /** The `ParentBehavior`'s children */
                                            children: Behavior[];
                                    }
                                    /**
                                        * This behavior remains `IN_PROGRESS` unless an action
                                        * explicitly fails or succeeds it. Useful for
                                        * blocking a sequence until an action (caused by
                                        * a head touch. for instance) forces it to continue.
                                        */
                                    interface Null extends Behavior {
                                            type: "NULL";
                                    }
                                    /**
                                        * Runs its children in parallel
                                        */
                                    interface Parallel extends ParentBehavior {
                                            type: "PARALLEL";
                                            /**
                                                * It `true`, succeeds after any one child succeeds. If `false`, succeeds
                                                * after all children succeed.
                                                */
                                            succeedOnFirst: boolean;
                                    }
                                    /**
                                        * Runs its children in sequence. Succeeds if all children succeed
                                        * and fails if any child fails.
                                        */
                                    interface Sequence extends ParentBehavior {
                                            type: "SEQUENCE";
                                    }
                                    /**
                                        * Runs its children in sequence until one succeeds, then
                                        * succeeds. If all children fail, `Select` fails unless
                                        * `alwaysSucceed` is `true`.
                                        */
                                    interface Select extends ParentBehavior {
                                            type: "SELECT";
                                            /** Defaults to `true` */
                                            alwaysSucceed?: boolean;
                                    }
                                    /**
                                        * Forces a behavior to succeed after the given amount of time
                                        */
                                    interface Timeout extends Decorator {
                                            type: "TIMEOUT";
                                            /** In ms */
                                            time: number;
                                    }
                                    type ConditionTypes = "EQUAL" | "GREATER_THAN" | "LESS_THAN" | "TRUE" | "FALSE" | "AND" | "OR" | "NOT";
                                    /**
                                        * Base interface to confition. Conditions allow for a simple way to check
                                        * against blackboard variables.
                                        * This allows the behavior tree to have branching logic and succeed or fail
                                        * behaviors based on dynamic input.
                                        */
                                    interface Condition {
                                            type: ConditionTypes;
                                    }
                                    /**
                                        * Always resolves to `true`
                                        */
                                    interface TrueCondition extends Condition {
                                            type: "TRUE";
                                    }
                                    /**
                                        * Always resolves to `false`
                                        */
                                    interface FalseCondition extends Condition {
                                            type: "FALSE";
                                    }
                                    /**
                                        * Checks that the value of the key in the blackboard matches
                                        * the value in this data structure. Uses a `===` check.
                                        */
                                    interface EqualCondition<T> extends Condition {
                                            type: "EQUAL";
                                            /** The blackboard key */
                                            key: string;
                                            /** The value to check */
                                            value: T;
                                    }
                                    /**
                                        * Checks that the value of the key in the blackboard is greater than
                                        * the value in this data structure
                                        */
                                    interface GreaterThanCondition extends Condition {
                                            type: "GREATER_THAN";
                                            /** The blackboard key */
                                            key: string;
                                            /** The value to check */
                                            value: number;
                                    }
                                    /**
                                        * Checks that the value of the key in the blackboard is less than
                                        * the value in this data structure.
                                        */
                                    interface LessThanCondition extends Condition {
                                            type: "LESS_THAN";
                                            key: string;
                                            value: number;
                                    }
                                    /** ANDs the conditions together */
                                    interface AndCondition extends Condition {
                                            type: "AND";
                                            conditions: Condition[];
                                    }
                                    /** ORs the conditions together */
                                    interface OrCondition extends Condition {
                                            type: "OR";
                                            conditions: Condition[];
                                    }
                                    /** NOTs the condition */
                                    interface NotCondition extends Condition {
                                            type: "NOT";
                                            condition: Condition;
                                    }
                                    /** Restarts its child behavior on success and if the condition is `true`. */
                                    interface While extends Decorator {
                                            type: "REPEAT";
                                            condition: Condition;
                                    }
                                    /**
                                        * Will succeed its child behavior on condition `true` and return
                                        * with status `SUCCEEDED`.
                                        */
                                    interface Succeed extends Decorator {
                                            type: "SUCCEED";
                                            condition: Condition;
                                    }
                                    /** Will fail its child behavior on condition true and return with status FAILED. */
                                    interface Fail extends Decorator {
                                            type: "FAIL";
                                            condition: Condition;
                                    }
                                    /**
                                        * Actions provide an extensible system for bindings between behaviors.
                                        * The actions are explicit, which makes the behavior
                                        * tree statically analyzable and safe across the wire.
                                        */
                                    type ActionTypes = "SUCCEED" | "FAIL" | "SELECT_MENU_ITEM" | "SHOW_DISPLAY" | "HIDE_DISPLAY" | "UPDATE_BLACKBOARD" | "RESET_BLACKBOARD" | "INCREMENT_BLACKBOARD";
                                    interface Action {
                                            type: ActionTypes;
                                    }
                                    /**
                                        * Updates the blackboard. First sets key value pairs in the order in `set`.
                                        * Then deletes keys in the order in `del`.
                                        */
                                    interface UpdateBlackboard extends Action {
                                            type: "UPDATE_BLACKBOARD";
                                            /** Sets these keys on the blackboard with the corresponding values
                                                *
                                                * `{key:string, value:any}[]`
                                                */
                                            set: {
                                                    key: string;
                                                    value: any;
                                            }[];
                                            /** Deletes the keys from blackboards */
                                            del: string[];
                                    }
                                    /**Increment a blackboard number */
                                    interface IncrementBlackboard extends Action {
                                            type: "INCREMENT_BLACKBOARD";
                                            /**
                                                * Key on the blackboard to increment.
                                                * If the key does not exist, it will set the value to `0`
                                                */
                                            key: string;
                                    }
                                    /** Deletes all keys on the blackboard */
                                    interface ResetBlackboard extends Action {
                                            type: "RESET_BLACKBOARD";
                                    }
                                    /**
                                        * Forces a behavior to return with status SUCCEED.
                                        * Each behavior type has explicitly defined behavior on forced success.
                                        *
                                        * e.g. For [[Play]] behavior: it will stop that behavior in the tree
                                        * and cancel TTS and any animations associated with it.
                                        *
                                        * For [[Display]] behavior: it will close the Display view
                                        * and an onCancelled event will be dispatched with that menu name.
                                        */
                                    interface SucceedAction extends Action {
                                            type: "SUCCEED";
                                            /** Unique name of the behavior */
                                            name: string;
                                    }
                                    /**
                                        * Fails the named bahvior. Each behavior type will
                                        * behave the same as if it was forced to succeed, except that behavior will
                                        * return with status FAILED. Probably used most often for behaviors
                                        * under a [[Select]].
                                        */
                                    interface FailAction extends Action {
                                            type: "FAIL";
                                            /** Unique name of the behavior */
                                            name: string;
                                    }
                                    /**
                                        * Spoofs an item-select in a [[MenuDisplay]].
                                        * The MenuDisplay config determines what actions to perform
                                        * on item selection.
                                        */
                                    interface SelectMenuItemAction extends Action {
                                            type: "SELECT_MENU_ITEM";
                                            menuName: string;
                                            itemName: string;
                                    }
                                    /**
                                        * Transitions in a display that is currently hidden and IN_PROGRESS.
                                        * No-op if the display is already shown and no-op (with warning event)
                                        * if the [[Display]] behavior has already succeeded or failed.
                                        */
                                    interface ShowDisplayAction extends Action {
                                            type: "SHOW_DISPLAY";
                                            /** Unique name of the display behavior */
                                            name: string;
                                    }
                                    /**
                                        * Transitions out a display that is currently shown.
                                        * No-op if the display is already hidden and no-op (with warning event)
                                        * if the [[Display]] behavior has already succeeded or failed.
                                        */
                                    interface HideDisplayAction extends Action {
                                            type: "HIDE_DISPLAY";
                                            /** Unique name of the display behavior */
                                            name: string;
                                    }
                                    interface StartOnFinishedOrient extends Decorator {
                                            type: "START_ON_FINISHED_ORIENT";
                                    }
                                    /**
                                        * Performs an Action such as showing or hiding a display
                                        */
                                    interface DoAction extends Behavior {
                                            actions: Action | Action[];
                                    }
                                    /**
                                        * On behavior `start`, the display will swoop in from the bottom if `visible`
                                        * is set to `true`. If `visible` is `false`, the display will not swoop in
                                        * until a [[ShowDisplayAction]] is called on it.
                                        * On succeed or failure, the menu will swoop out to the top.
                                        */
                                    interface Display extends Behavior {
                                            type: "DISPLAY";
                                            /**
                                                * Whether this display is visible when this behavior is
                                                * started
                                                */
                                            keepDisplay: boolean;
                                            visible: boolean;
                                            /** Must be unique */
                                            name: string;
                                            overlay?: "dim" | "clear";
                                            layer: 0 | 1 | 2 | 3 | 4;
                                            /** Actions to perform when this display is dismissed */
                                            onCancel: Action[];
                                            view: EyeDisplay | NoneDisplay | MenuDisplay | Image | PhotoGallery | LoopMembersMenu | SkillDisplay | TextDisplay;
                                    }
                                    type DisplayViewType = "SKILL" | "MENU" | "IMAGE" | "LOOP_MENU" | "PHOTO_GALLERY" | "TEXT" | "EYE" | "NONE";
                                    interface DisplayView {
                                            type: DisplayViewType;
                                            name: string;
                                    }
                                    interface NoneDisplay extends DisplayView {
                                            type: "NONE";
                                    }
                                    interface TextDisplay extends DisplayView {
                                            type: "TEXT";
                                            text: string;
                                    }
                                    interface EyeDisplay extends DisplayView {
                                            type: "EYE";
                                    }
                                    /**This shows the contents of WebEngine. I.e. the skill's DOM. */
                                    interface SkillDisplay extends DisplayView {
                                            type: "SKILL";
                                            /** Arbitrary object injected into the skill view */
                                            context: any;
                                    }
                                    /** A normal selection menu. */
                                    interface MenuDisplay extends DisplayView {
                                            type: "MENU";
                                            title: string;
                                            contents: MenuElement[];
                                            startIndex: number;
                                    }
                                    /** Represents an item in the [[MenuDisplay]] */
                                    interface MenuElement {
                                            /**
                                                * Must be unique within this menu since this field
                                                * is referenced by a [[SelectMenuItemAction]]
                                                */
                                            name: string;
                                            /** Arbitrary data to put in the menu */
                                            data: any;
                                            image?: Image;
                                            color?: string;
                                            text: string;
                                            onSelect?: Action[];
                                    }
                                    /** Displays an image */
                                    interface Image extends DisplayView {
                                            type: "IMAGE";
                                            /** `{url:string;} | {name:string; set:string} | {blackboardKey:string}` */
                                            data: {
                                                    url: string;
                                            } | {
                                                    name: string;
                                                    set: string;
                                            } | {
                                                    blackboardKey: string;
                                            };
                                            onClick: Action[];
                                    }
                                    interface LoopMembersMenu extends DisplayView {
                                            type: "LOOP_MENU";
                                            /** Only display the members whose ids are in this array */
                                            memberIds?: string[];
                                            /** When a loop member is selected */
                                            onSelect: Action[];
                                    }
                                    interface PhotoGallery extends DisplayView {
                                            type: "PHOTO_GALLERY";
                                            /**
                                                * Start at either the specified index or at the specified photo.
                                                *
                                                * `{index:number} | {photoId:string}`
                                                */
                                            start: {
                                                    index: number;
                                            } | {
                                                    photoId: string;
                                            };
                                            /**
                                                * If `true` the gallery will open with the full size image
                                                * of the first picture in the gallery or the specified picture
                                                * from the start field
                                                */
                                            fullscreen?: boolean;
                                            /** When a photo is selected */
                                            onSelect: Action[];
                                            onSelectBlackboardKey: string;
                                    }
                                    /**
                                        * Turns on ASR and the cooresponding
                                        * event stream, and optionally parses against multiple intents.
                                        */
                                    interface Listen extends Behavior {
                                            type: "LISTEN";
                                            intents?: Intent[];
                                            contexts: string[];
                                    }
                                    type IntentType = "CUSTOM" | "MENU_NAV" | "CANCEL";
                                    /**
                                        * Represents a Dialogflow authored intent. If an intent is
                                        * defined in a [[Listen]] behavior, the results of the intent will
                                        * be part of the listen event stream.
                                        * Optionally, intents and their cooresponding entities can be bound to
                                        * actions in the behavior tree.
                                        */
                                    interface Intent {
                                            type: IntentType;
                                    }
                                    /**
                                        * A special intent that automatically performs
                                        * actions like "next" and "previous" and are automatically
                                        * bound to the menu name
                                        */
                                    interface MenuNavIntent extends Intent {
                                            type: "MENU_NAV";
                                            /** The menu name to control with this intent. */
                                            menuName: string;
                                    }
                                    /**
                                        * A custom intent is one created by the skill developer
                                        * and can optionally be used to trigger actions either
                                        * if this intent is returned, or if there are any entities
                                        * in an intent that match what was said.
                                        */
                                    interface CustomIntent extends Intent {
                                            type: "CUSTOM";
                                            /** The full name of this intent */
                                            name: string;
                                            /** Perform these actions in parallel if this intent is returned. */
                                            intentActions?: Action[];
                                            /**
                                                * Try to match against any entities that were returned and
                                                * perform the cooresponding actions.
                                                */
                                            entityActions?: EntityActionBinding<any>[];
                                    }
                                    /** This binds a matched entity with an action */
                                    interface EntityActionBinding<EntityType> {
                                            /** The entity's parameter name */
                                            entityName: string;
                                            /**
                                                * Perform the actions below if this entity's return value
                                                * matches this field. Note that the entity type must match
                                                * the matchingValue type.
                                                */
                                            matchingValue: EntityType;
                                            /** Actions to take if it's a match */
                                            actions: Action[];
                                    }
                                    /** A play behavior. */
                                    interface Play extends Behavior {
                                            type: "PLAY";
                                            esml: string;
                                            autoRuleConfig?: any;
                                            speakOptions?: any;
                                    }
                                    interface Vector2 {
                                            x: number;
                                            y: number;
                                    }
                                    interface Vector3 extends Vector2 {
                                            z: number;
                                    }
                                    type DOFSet = "BASE" | "EYE" | "BODY" | "ALL";
                                    /** Plays an animation. Fails if it could not find an animation to play */
                                    interface PlayAnimation extends Behavior {
                                            type: "PLAY_ANIMATION";
                                            /**
                                                * The animation to play. Can either be a url, the raw anim data, an AnimDB query
                                                * or an animaiton that matches a category or set of categories.
                                                *
                                                * `{url:string} | {data:any} | {query:string} | {categories:string | string[]}`
                                                */
                                            animation: {
                                                    url: string;
                                            } | {
                                                    data: any;
                                            } | {
                                                    query: string;
                                            } | {
                                                    categories: string | string[];
                                            };
                                            options?: {
                                                    /** DOFs this animation is applied to. */
                                                    dofs?: DOFSet;
                                                    /** Speed scaling factor for this animation. */
                                                    speed?: number;
                                                    /** number of loops. `-1` means to loop infinitely. */
                                                    loops?: number;
                                            };
                                    }
                                    /**
                                        * Will succeed when it has reached its target.
                                        * Will remain IN_PROGRESS if `track` is `true`.
                                        */
                                    interface LookAt extends Behavior {
                                            type: "LOOKAT";
                                            /** Without track will go and hold
                                                *
                                                *  {position:[[Vector3]]} |
                                                *  {angleVector:[[Vector2]]} |
                                                *  {cameraTarget:[[Vector2]]} |
                                                *  {entityId:string, track:boolean}
                                                */
                                            target: {
                                                    position: Vector3;
                                            } | {
                                                    angleVector: Vector2;
                                            } | {
                                                    cameraTarget: Vector2;
                                            } | {
                                                    entityId: string;
                                                    track: boolean;
                                            };
                                            options: {
                                                    type: "LEVEL_HEAD" | "FLUSH_BASE";
                                                    dofs: DOFSet;
                                            };
                                    }
                                    interface TakePhoto extends Behavior {
                                            type: "TAKE_PHOTO";
                                            camera: "narrow" | "wide";
                                            resolution: "snap" | "preview";
                                            distortion: boolean;
                                            /** Puts the url of taken photo on the blackboard */
                                            blackboardKey: string;
                                    }
                                    /**
                                        * Turns on the head touch event stream, but can also be bound
                                        * to actions
                                        */
                                    interface HeadTouch extends Behavior {
                                            type: "HEAD_TOUCH";
                                            /** Succeed this beahvior when the head is touched */
                                            succeedOnTouch: boolean;
                                            /** The action to take when a head touch occurs */
                                            actions: Action[];
                                    }
                                    /** Shows the viewfinder */
                                    interface ViewFinder extends Behavior {
                                            type: "VIEWFINDER";
                                            area: {
                                                    x: number;
                                                    y: number;
                                                    width: number;
                                                    height: number;
                                            };
                                    }
                                    /** Valid Configurations of a SLIM */
                                    interface SLIMConfig {
                                            play?: Play;
                                            listen?: Listen;
                                            display?: Display;
                                    }
                                    /** Valid Options of a SLIM */
                                    interface SLIMOptions {
                                            displayMode: "START_ON_PLAY" | "START_ON_LISTEN";
                                    }
                                    /** This is a SLIM */
                                    interface SLIM extends Behavior {
                                            type: "SLIM";
                                            config: SLIMConfig;
                                            options?: SLIMOptions;
                                    }
                                    /**
                                        * Sets/overrides who Jibo believes is the present person.
                                        */
                                    interface SetPresentPerson extends Behavior {
                                            type: "SET_PRESENT_PERSON";
                                            /** Loop member's ID */
                                            looperId: string;
                                            /** The source of the ID */
                                            source: "VOICE" | "FACE" | "USER_OVERRIDE";
                                            /** Confidence level in this ID */
                                            confidence: number;
                                    }
                                    /**
                                        * Impact Jibo's current emotional state.
                                        */
                                    interface ImpactEmotion extends Behavior {
                                            type: "IMPACT_EMOTION";
                                            /** Impact the valence axis */
                                            valence?: "NONE" | "LOW_POS" | "MEDIUM_POS" | "HIGH_POS" | "LOW_NEG" | "MEDIUM_NEG" | "HIGH_NEG";
                                            /** Impact the confidence axis */
                                            confidence?: "NONE" | "LOW_POS" | "MEDIUM_POS" | "HIGH_POS" | "LOW_NEG" | "MEDIUM_NEG" | "HIGH_NEG";
                                    }
                            }
                            namespace events {
                                    type EventType = "STARTED" | "SUCCEEDED" | "FAILED" | "CANCELED" | "ITEM_SELECTED" | "LOOP_MEMBER_SELECTED" | "PHOTO_SELECTED" | "LISTEN" | "MOTION" | "ENTITY" | "HEAD_TOUCH" | "HEAD_HOLD" | "RESOURCES_OVERRIDDEN" | "CLOSE" | "HOTWORD" | "HEY_JIBO";
                                    /**
                                        * Base interface for robot events. These are events that are not
                                        * behavior tree based, but are global in nature.
                                        */
                                    interface RobotEvent {
                                            type: "EVENT";
                                            time: [number, number];
                                            name: EventType;
                                    }
                                    /**
                                        * Events that are emitted from Behaviors
                                        */
                                    interface BehaviorEvent extends RobotEvent {
                                            /**
                                                * The transaction id of the command that started
                                                * this behavior tree
                                                */
                                            startBehaviorTransactionId: string;
                                            /** The name of the behavior this was emitted from */
                                            behaviorId: string;
                                    }
                                    /** Dispatched when a behavior starts */
                                    interface StartedEvent extends BehaviorEvent {
                                            name: "STARTED";
                                    }
                                    /** Dispatched when a behavior succeeds */
                                    interface SucceededEvent extends BehaviorEvent {
                                            name: "SUCCEEDED";
                                    }
                                    /** Dispatched when a behavior fails */
                                    interface FailedEvent extends BehaviorEvent {
                                            name: "FAILED";
                                    }
                                    /**
                                        * Dispatched when one behavior overrides and uses a resource
                                        * another behavior was using
                                        */
                                    interface ResourcesOverriddenEvent extends BehaviorEvent {
                                            name: "RESOURCES_OVERRIDDEN";
                                            /**
                                                * The resources that this behavior was using that were
                                                * overridden by an other behavior.
                                                *
                                                * `{type:`[[ResourceType]]`, startBehaviorTransactionId:string, behaviorName:string}[]`
                                                */
                                            resourcesOverriden: {
                                                    type: resources.ResourceType;
                                                    /**
                                                        * The transaction id of start command of the tree that
                                                        * contains the behavior that used the overridden resource.
                                                        */
                                                    startBehaviorTransactionId: string;
                                                    behaviorName: string;
                                            }[];
                                            /**
                                                * The resources that this behavior was using at the time
                                                * one of its resources was overridden
                                                */
                                            resourcesUsed: resources.ResourceType[];
                                    }
                                    /** Dispatched when a display has been canceled  */
                                    interface CanceledEvent extends BehaviorEvent {
                                            name: "CANCELED";
                                    }
                                    interface ItemSelectedEvent extends BehaviorEvent {
                                            name: "ITEM_SELECTED";
                                            /** References the [[MenuElement.name]] field */
                                            itemName: string;
                                            /** [[MenuElement.data]] */
                                            data: any;
                                    }
                                    interface LoopMemberSelectedEvent extends BehaviorEvent {
                                            name: "LOOP_MEMBER_SELECTED";
                                            /** The loop member Id */
                                            loopMemeberId: string;
                                    }
                                    interface PhotoSelectedEvent extends BehaviorEvent {
                                            name: "PHOTO_SELECTED";
                                            /** The id of the selected photo */
                                            photoId: string;
                                    }
                                    /**
                                        * Emitted when a hotword is detected. For now this will
                                        * only ever be "Hey Jibo". This event exists to grab the speaker
                                        * ID sooner than returned from the listen event.
                                        */
                                    interface HotwordEvent extends RobotEvent {
                                            name: "HOTWORD";
                                            /** The location of the speaker */
                                            lps: {
                                                    position: math.Vector3;
                                                    angle: math.Vector2;
                                                    confidence: number;
                                            };
                                            /** The speaker ID
                                                *
                                                * `{type:"PERSON", loopMemberId:string, confidence:number}[]` |
                                                *
                                                * `{type:"UNKNOWN"}`
                                                */
                                            speakerId: {
                                                    type: "PERSON";
                                                    loopMemberId: string;
                                                    confidence: number;
                                            }[] | {
                                                    type: "UNKNOWN";
                                            };
                                            hotwordType: "HEY_JIBO";
                                    }
                                    interface ListenEvent extends BehaviorEvent {
                                            name: "LISTEN";
                                            /** The location of the speaker */
                                            lps: {
                                                    position: math.Vector3;
                                                    angle: math.Vector2;
                                                    confidence: number;
                                            };
                                            /**
                                                * `{type:"PERSON", loopMemberId:string, confidence:number}[]` |
                                                *
                                                * `{type:"UNKNOWN"}`
                                                */
                                            speakerId: {
                                                    type: "PERSON";
                                                    loopMemberId: string;
                                                    confidence: number;
                                            }[] | {
                                                    type: "UNKNOWN";
                                            };
                                            /** The NLU object */
                                            nlu: {
                                                    intent: string;
                                                    entities: {
                                                            [name: string]: string;
                                                    };
                                            };
                                            /** The words spoken with confidence */
                                            asr: {
                                                    text: string;
                                                    confidence: number;
                                            };
                                    }
                                    interface MotionEvent extends RobotEvent {
                                            name: "MOTION";
                                            /** All motions being detected */
                                            lps: {
                                                    position: math.Vector3;
                                                    screen: math.Vector2;
                                                    intensity: number;
                                            }[];
                                    }
                                    /**
                                        * The skill gets this event right when a user either
                                        * swipes down on the [[SkillDisplay]], or when a [[HeadHold]]
                                        * happens.
                                        */
                                    interface CloseEvent extends RobotEvent {
                                            name: "CLOSE";
                                    }
                                    interface HeyJiboEvent extends RobotEvent {
                                            name: "HEY_JIBO";
                                            id: {
                                                    loopMemberId: string;
                                                    confidence: number;
                                            };
                                            location: {
                                                    position: math.Vector3;
                                                    screen: math.Vector2;
                                            };
                                    }
                                    interface EntityEvent extends RobotEvent {
                                            name: "ENTITY";
                                            /** The id of the entity. */
                                            id: string;
                                            lps: {
                                                    position: math.Vector3;
                                                    screen: math.Vector2;
                                                    intensity: number;
                                            };
                                            /** If the lps thinks this person is in the loop */
                                            memberId?: string;
                                    }
                                    interface HeadTouchEvent extends BehaviorEvent {
                                            name: "HEAD_TOUCH";
                                            pads: number[];
                                    }
                                    interface HeadHoldEvent extends BehaviorEvent {
                                            name: "HEAD_HOLD";
                                            pads: number[];
                                    }
                            }
                            namespace resources {
                                    /** Resources are singletons.
                                        * `AUDIO` - Additive up to 10 channels
                                        *
                                        * `TTS, MOTION, CAMERA, LISTEN, VIEWFINDER` - Singleton resource. Cannot be shared.
                                        *
                                        * `DISPLAY0, DISPLAY1, DISPLAY2, DISPLAY3, DISPLAY4` - Singleton resource. Cannot be shared.
                                        *
                                        * `EYE_DISPLAY` - Can only have one eye layer.
                                        *
                                        * `SKILL_DISPLAY` - Can only have one skill layer.
                                        */
                                    type ResourceType = 
                                    /** This resource is additive up to 10 channels */
                                    "AUDIO" | 
                                    /** Singleton resource. Cannot be shared. */
                                    "TTS" | 
                                    /** Singleton resource. Cannot be shared. */
                                    "MOTION" | 
                                    /** Singleton resource. Cannot be shared. */
                                    "CAMERA" | 
                                    /** Singleton resource. Cannot be shared. */
                                    "LISTEN" | 
                                    /**
                                        * Each display layer is a singleton resource and
                                        * cannot be shared.
                                        */
                                    "DISPLAY0" | "DISPLAY1" | "DISPLAY2" | "DISPLAY3" | "DISPLAY4" | 
                                    /** Can only have one eye layer */
                                    "EYE_DISPLAY" | 
                                    /** Can only have one skill layer */
                                    "SKILL_DISPLAY" | 
                                    /** Singleton */
                                    "VIEWFINDER";
                            }
                            namespace aco {
                                    type PermissionsSet = behaviors.RobotBehaviorType;
                                    /**
                                        * The Application Control Object. This describes
                                        * the permissions of a skill
                                        */
                                    interface ACO {
                                            /**
                                                * The version of this ACO object. This allows us
                                                * to update and refine the command set in the future
                                                */
                                            version: string;
                                            appId: string;
                                            /** Describes the behaviors this skill is allowed to execute */
                                            permissionsSet: PermissionsSet[] | "ALL";
                                            appConfig: {
                                                    speechConfig: {
                                                            maxSpeechTimeout: number;
                                                    } | {
                                                            maxNoSpeechTimeout: number;
                                                    };
                                            };
                                            keepAliveTimeout: number;
                                            recoveryTimeout: number;
                                    }
                            }
                            /**
                                * Types used exclusively in Pegasus
                                */
                            namespace pegasus {
                                    namespace behaviors {
                                            type Display = JIBO.v2.behaviors.Display;
                                            type Listen = JIBO.v2.behaviors.Listen;
                                            type Play = JIBO.v2.behaviors.Play;
                                            type SLIM = JIBO.v2.behaviors.SLIM;
                                            type Sequence = JIBO.v2.behaviors.Sequence;
                                            type Parallel = JIBO.v2.behaviors.Parallel;
                                            type SetPresentPerson = JIBO.v2.behaviors.SetPresentPerson;
                                            type ImpactEmotion = JIBO.v2.behaviors.ImpactEmotion;
                                    }
                            }
                    }
            }
    }
}

declare module 'roboconnection/connection/JiboConnection' {
    import { EventEmitter } from "events";
    import { Requester } from 'roboconnection/connection/jibo-command-requester';
    export interface ConnectionInfo {
        clientId: string;
        clientSecret: string;
        port?: number;
    }
    export interface RobotInfo {
        name?: string;
        serialName: string;
        endpoint: string;
        email: string;
        password: string;
        ip?: string;
        onConnected?: any;
        onDisconnected?: any;
    }
    export class JiboConnection extends EventEmitter {
        static MAX_TRIES: number;
        static DEFAULT_PORT: number;
        static DEV_ENDPOINT: string;
        static STG_ENDPOINT: string;
        static PREPROD_ENDPOINT: string;
        static PROD_ENDPOINT: string;
        static ENVIRONMENT_OPTIONS: any;
        constructor(robotInfo: RobotInfo, connectionInfo: ConnectionInfo);
        connect(debugLogging?: boolean): void;
        login(): void;
        getRobotList(): void;
        createCertificate(): void;
        retrieveCertificate(): void;
        connectToRobot(ipAddress: string, key: string, cert: string, fingerprint: string, callback: any): void;
        disconnect(): void;
        readonly connected: boolean;
        readonly requester: Requester | undefined;
        statusMessage(message: string, clearMessages?: boolean): void;
        logDebug(...args: any[]): void;
        logError(...args: any[]): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/Requester' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import { v1 } from 'roboconnection/connection/jibo-command-requester/requests';
    import Attention = v1.expression.attention.Attention;
    import LookAt = v1.expression.lookAt.LookAt;
    import Display = v1.expression.display.Display;
    import VideoPlayback = v1.expression.video.VideoPlayback;
    import FaceTrack = v1.lps.face.FaceTrack;
    import MotionTrack = v1.lps.motion.MotionTrack;
    import HotWord = v1.listen.hotWord.HotWord;
    import Listen = v1.listen.listen.Listen;
    import Play = v1.expression.play.Play;
    import Photo = v1.camera.photo.Photo;
    import Video = v1.camera.video.Video;
    import LoadAssets = v1.loadAssets.LoadAssets;
    import UnloadAssets = v1.unloadAssets.UnloadAssets;
    import HeadTouch = v1.sensory.headTouch.HeadTouch;
    import GetConfig = v1.settings.getConfig.GetConfig;
    import SetConfig = v1.settings.setConfig.SetConfig;
    import ScreenGesture = v1.sensory.screenGesture.ScreenGesture;
    import { Event } from 'roboconnection/connection/jibo-command-requester/events/Event';
    /**
        * Entry point for the Remote Client Protocol.
        * @class Requester
        * @example
        * const requester = new Requester();
        * requester.disconnected.on((data) => {
        *     console.log('Connection closed because', data);
        * });
        * await requester.connect(robotName);
        */
    export default class Requester {
            /**
                * @name Requester#attention
                * @description Instance property on the Requester class. See {@link Requester.attention} namespace.
                */
            attention: Attention;
            /**
                * @name Requester#lookAt
                * @description Instance property on the Requester class. See {@link Requester.lookAt} namespace.
                */
            lookAt: LookAt;
            /**
                * @name Requester#display
                * @description Instance property on the Requester class. See {@link Requester.display} namespace.
                */
            display: Display;
            /**
                * @name Requester#display
                * @description Instance property on the Requester class. See {@link Requester.videoPlayback} namespace.
                */
            videoPlayback: VideoPlayback;
            /**
                * @name Requester#faceTrack
                * @description Instance property on the Requester class. See {@link Requester.faceTrack} namespace.
                */
            faceTrack: FaceTrack;
            /**
                * @name Requester#motionTrack
                * @description Instance property on the Requester class. See {@link Requester.motionTrack} namespace.
                */
            motionTrack: MotionTrack;
            /**
                * @name Requester#play
                * @description Instance property on the Requester class. See {@link Requester.play} namespace.
                */
            play: Play;
            /**
                * @name Requester#photo
                * @description Instance property on the Requester class. See {@link Requester.photo} namespace.
                */
            photo: Photo;
            /**
                * @name Requester#video
                * @description Instance property on the Requester class. See {@link Requester.video} namespace.
                */
            video: Video;
            /**
                * @name Requester#listen
                * @description Instance property on the Requster class. See {@link Requester.listen} namespace.
                */
            listen: Listen;
            /**
                * @name Requester#hotWord
                * @description Instance property on the Requester class. See {@link Requester.hotWord} namespace.
                */
            hotWord: HotWord;
            /**
                * @name Requester#loadAssets
                * @description Instance property on the Requester class. See {@link Requester.loadAssets} namespace.
                */
            loadAssets: LoadAssets;
            /**
                * @name Requester#unloadAssets
                * @description Instance property on the Requester class. See {@link Requester.unloadAssets} namespace.
                */
            unloadAssets: UnloadAssets;
            /**
                * @name Requester#headTouch
                * @description Instance property on the Requester class. See {@link Requester.headTouch} namespace.
                */
            headTouch: HeadTouch;
            /**
                * @name Requester#getConfig
                * @description Instance property on the Requester class. See {@link Requester.getConfig} namespace.
                */
            getConfig: GetConfig;
            /**
                * @name Requester#setConfig
                * @description Instance property on the Requester class. See {@link Requester.setConfig} namespace.
                */
            setConfig: SetConfig;
            /**
                * @name Requester#screenGesture
                * @description Instance property on the Requester class. See {@link Requester.screenGesture} namespace.
                */
            screenGesture: ScreenGesture;
            /**
                * ID for the app.
                * @name Requester#AppID
                * @type string
                */
            AppID: string;
            /**
                * Event emitted when the connection is closed by the robot or a connection issue.
                * @name Requester#disconnected
                * @type Event<number, string>
                */
            disconnected: Event<{
                    code: number;
                    reason: string;
            }>;
            expression: any;
            config: any;
            perception: any;
            constructor();
            /**
                * Connect to the specific robot.
                * @method Requester#connect
                * @param  {string}        robotName your-friendly-robot-name
                * @return {Promise<void>}
                */
            connect(robotName: string, options: any): Promise<void>;
            /**
                * Disconnect all active connections.
                * @method Requester.disconnect
                */
            disconnect(): void;
            /**
                * @private
                */
            sendRequest(command: JIBO.v1.BaseCommand): string;
            /**
                * @private
                */
            sendToken(token: RequestToken<any>): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester' {
    export { default as Requester } from 'roboconnection/connection/jibo-command-requester/Requester';
    export * from 'roboconnection/connection/jibo-command-requester/requests';
    import * as enums from 'roboconnection/connection/jibo-command-protocol';
    export { enums };
    export { Event } from 'roboconnection/connection/jibo-command-requester/events/Event';
}

declare module 'roboconnection/connection/jibo-command-requester/tokens/RequestToken' {
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import ExternalPromise from 'roboconnection/connection/jibo-command-requester/utils/ExternalPromise';
    /**
        * Every request has a token with a completion promise and any events relative to that command.
        * @class RequestToken
        */
    export default abstract class RequestToken<C extends JIBO.v1.BaseCommand, Result = any> {
            /**
                * Protocol data to be sent along the websocket.
                * @private
                */
            protocol: C;
            /**
                * Unique id for this request, and any responses to it.
                * @private
                */
            requestId: string;
            /**
                * Internal flag for the Requester to know that it no longer needs to track the token. Must
                * be updated by subclasses when `complete` resolves.
                * @private
                */
            isComplete: boolean;
            /**
                * For subclasses to know where to send cancel requests
                * @private
                */
            owner: Requester;
            protected _complete: ExternalPromise<Result>;
            /**
                * Request completion promise.
                * @method RequestToken#complete
                * @returns this
                */
            readonly complete: Promise<Result>;
            /** @private */
            constructor(owner: Requester, protocol: C);
            /**
                * Cancel the request.
                * @method RequestToken#cancel
                */
            cancel(): void;
            /**
                * Internal listener method for handling responses
                * @private
                */
            abstract handleAck(data: JIBO.v1.Acknowledgement): void;
            /**
                * Internal listener method for handling responses
                * @private
                */
            abstract handleEvent(data: JIBO.v1.EventMessage): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests' {
    import * as v1 from 'roboconnection/connection/jibo-command-requester/requests/v1';
    import * as v2 from 'roboconnection/connection/jibo-command-requester/requests/v2';
    export { v1, v2 };
}

declare module 'roboconnection/connection/jibo-command-requester/events/Event' {
    export interface Handler<Type> {
        (data?: Type): void;
    }
    export enum EmitterMode {
        ALL_HANDLERS = "ALL_HANDLERS",
        FIRST_HANDLER = "FIRST_HANDLER",
        LAST_HANDLER = "LAST_HANDLER"
    }
    export class Event<Type> {
        name: string;
        constructor(name: string);
        listeners(): Handler<Type>[];
        setMaxListeners(n: number): this;
        getMaxListeners(): number;
        once(handler: Handler<Type>): this;
        on(handler: Handler<Type>): this;
        removeLastListener(): void;
        removeFirstListener(): void;
        addListener(handler: Handler<Type>): this;
        removeListener(handler: Handler<Type>): this;
        off(handler: Handler<Type>): this;
        removeAllListeners(): this;
        emit(data?: Type): boolean;
        setMode(mode: EmitterMode): void;
        waitFor(timeoutMs?: number): Promise<Type>;
        listenerCount(): number;
    }
}

declare module 'roboconnection/connection/jibo-command-protocol' {
    export * from 'roboconnection/connection/jibo-command-protocol/Enums';
    import * as typeguards from 'roboconnection/connection/jibo-command-protocol/TypeGuards';
    export { typeguards };
}

declare module 'roboconnection/connection/jibo-command-requester/utils/ExternalPromise' {
    export default class ExternalPromise<T> {
        resolve: (d?: T) => any;
        reject: (err?: any) => any;
        promise: Promise<T>;
        constructor();
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1' {
    import * as loadAssets from 'roboconnection/connection/jibo-command-requester/requests/v1/LoadAssets';
    import * as unloadAssets from 'roboconnection/connection/jibo-command-requester/requests/v1/UnloadAssets';
    import * as session from 'roboconnection/connection/jibo-command-requester/requests/v1/Session';
    import * as camera from 'roboconnection/connection/jibo-command-requester/requests/v1/camera';
    import * as expression from 'roboconnection/connection/jibo-command-requester/requests/v1/expression';
    import * as listen from 'roboconnection/connection/jibo-command-requester/requests/v1/listen';
    import * as lps from 'roboconnection/connection/jibo-command-requester/requests/v1/lps';
    import * as sensory from 'roboconnection/connection/jibo-command-requester/requests/v1/sensory';
    import * as settings from 'roboconnection/connection/jibo-command-requester/requests/v1/settings';
    export { loadAssets, unloadAssets, session, camera, expression, listen, lps, sensory, settings };
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v2' {
    import * as structural from 'roboconnection/connection/jibo-command-requester/requests/v2/structural';
    import * as emotion from 'roboconnection/connection/jibo-command-requester/requests/v2/emotion';
    import * as perception from 'roboconnection/connection/jibo-command-requester/requests/v2/perception';
    import * as play from 'roboconnection/connection/jibo-command-requester/requests/v2/Play';
    import * as listen from 'roboconnection/connection/jibo-command-requester/requests/v2/Listen';
    import * as display from 'roboconnection/connection/jibo-command-requester/requests/v2/Display';
    import * as slim from 'roboconnection/connection/jibo-command-requester/requests/v2/SLIM';
    /**
      * @description Namespace for the v2 RCP protocol.
      * </br> See [Phoenix RCP](https://github.jibo.com/phoenix/jibo-command-protocol) for all `JIBO` docs.
      * @namespace Requester.v2
      * @intdocs
      */
    export { play, listen, display, slim, perception, emotion, structural };
}

declare module 'roboconnection/connection/jibo-command-protocol/Enums' {
    /**
        * Enum of TakePhoto events.
        * @intdocs
        * @typedef PhotoEvents
        * @prop TakePhoto `onTakePhoto`
        */
    export const PhotoEvents: {
            TakePhoto: JIBO.v1.PhotoEvents.TakePhoto;
    };
    /**
        * Enum of video events
        * @typedef VideoEvents
        * @intdocs
        * @prop VideoReady `onVideoReady`
        */
    export const VideoEvents: {
            VideoReady: JIBO.v1.VideoEvents.VideoReady;
    };
    /**
        * @description Enum of skill disconnect reasons
        * @typedef DisconnectReason
        * @prop 4000 Skill closed by user
        * @prop 4001 Skill closed due to robot error
        * @prop 4002 Incoming connection is replacing previous connection
        * @prop 4003 Connection closed due to inactivity
        * @prop 4004 Session closed due to reconnection time out
        * @prop 4005 Session closed due to failed reconnection
        */
    export const DisconnectReason: JIBO.v1.DisconnectReason;
    /**
        * Enum of websocket close codes
        * @typedef DisconnectCode
        * @intdocs
        * @prop HeadTouchExit `4000` - The Remote skill was exited via head touch on robot
        * @prop RobotError `4001` - The Remote skill was exited due to an error on the robot resulting in the error display taking over.
        * @prop NewConnection `4002` - A new Remote connection is superseding the existing one.
        * @prop InactivityTimeout `4003` - The connection was closed due to inactivity (no commands sent)
        * @prop ReconnectTimeout `4004` - Session timed out waiting for reconnect
        * @prop ReconnectError `4005` - Session unable to wait for a reconnect
        */
    export const DisconnectCode: {
            HeadTouchExit: JIBO.v1.DisconnectCodes.HeadTouchExit;
            RobotError: JIBO.v1.DisconnectCodes.RobotError;
            NewConnection: JIBO.v1.DisconnectCodes.NewConnection;
            InactivityTimeout: JIBO.v1.DisconnectCodes.InactivityTimeout;
            ReconnectTimeout: JIBO.v1.DisconnectCodes.ReconnectTimeout;
            ReconnectError: JIBO.v1.DisconnectCodes.ReconnectError;
    };
    /**
        * @typedef ResponseStrings
        * @intdocs
        * @description Maps the [Response Code]{@link ResponseCode} numbers to their strings (i.e. `200` = `OK`, `404` = `NotFound`, etc).
        */
    export const ResponseStrings: JIBO.v1.ResponseStrings;
    /**
        * Enum of Jibo's available attention modes.
        * @typedef AttentionMode
        * @prop Off
        * @prop Idle
        * @prop Disengage
        * @prop Engaged
        * @prop Speaking
        * @prop Fixated
        * @prop Attractable
        * @prop Menu
        * @prop Command
        */
    export const AttentionMode: {
            Off: JIBO.v1.AttentionModes.Off;
            Idle: JIBO.v1.AttentionModes.Idle;
            Disengage: JIBO.v1.AttentionModes.Disengage;
            Engaged: JIBO.v1.AttentionModes.Engaged;
            Speaking: JIBO.v1.AttentionModes.Speaking;
            Fixated: JIBO.v1.AttentionModes.Fixated;
            Attractable: JIBO.v1.AttentionModes.Attractable;
            Menu: JIBO.v1.AttentionModes.Menu;
            Command: JIBO.v1.AttentionModes.Command;
    };
    /**
        * @typedef CommandTypes
        * @intdocs
        * @description Enum of command types.
        * @prop StartSession
        * @prop GetConfig
        * @prop SetConfig
        * @prop Cancel
        * @prop Display
        * @prop SetAttention
        * @prop Say
        * @prop Listen
        * @prop LookAt
        * @prop TakePhoto
        * @prop Video
        * @prop Subscribe
        * @prop FetchAsset
        * @prop VideoPlayback
        * @prop UnloadAsset
        */
    export const CommandTypes: {
            StartSession: JIBO.v1.Commands.StartSession;
            GetConfig: JIBO.v1.Commands.GetConfig;
            SetConfig: JIBO.v1.Commands.SetConfig;
            Cancel: JIBO.v1.Commands.Cancel;
            Display: JIBO.v1.Commands.Display;
            SetAttention: JIBO.v1.Commands.SetAttention;
            Say: JIBO.v1.Commands.Say;
            Listen: JIBO.v1.Commands.Listen;
            LookAt: JIBO.v1.Commands.LookAt;
            TakePhoto: JIBO.v1.Commands.TakePhoto;
            Video: JIBO.v1.Commands.Video;
            Subscribe: JIBO.v1.Commands.Subscribe;
            FetchAsset: JIBO.v1.Commands.FetchAsset;
            VideoPlayback: JIBO.v1.Commands.VideoPlayback;
            UnloadAsset: JIBO.v1.Commands.UnloadAsset;
    };
    /**
        * Enum of async command events.
        * @typedef AsyncCommandEvent
        * @intdocs
        * @prop Start `onStart` - Asynchronous command has started.
        * @prop Stop `onStop` - Asynchronous command has stopped.
        * @prop Error `onError` - An attempt to move from Requested to Start resulted in an Error.
        */
    export const AsyncCommandEvent: {
            Start: JIBO.v1.AsyncCommandEvents.Start;
            Stop: JIBO.v1.AsyncCommandEvents.Stop;
            Error: JIBO.v1.AsyncCommandEvents.Error;
    };
    /**
        * Enum of display events.
        * @typedef DisplayEvents
        * @intdocs
        * @prop ViewStateChange `onViewStateChange`
        */
    export const DisplayEvents: {
            ViewStateChange: JIBO.v1.DisplayEvents.ViewStateChange;
    };
    /**
        * Enum of possible view states
        * @intdocs
        * @typedef ViewStates
        * @prop Opened
        * @prop Closed
        */
    export const ViewStates: {
            Opened: JIBO.v1.ViewStates.Opened;
            Closed: JIBO.v1.ViewStates.Closed;
    };
    /**
        * @typedef DisplayViewType
        * @description Enum of available display types
        * @prop Eye Display Jibo's eye on screen.
        * @prop Text Display text on screen.
        * @prop Image Display an image on screen.
        */
    export const DisplayViewType: {
            Eye: JIBO.v1.DisplayViews.Eye;
            Text: JIBO.v1.DisplayViews.Text;
            Image: JIBO.v1.DisplayViews.Image;
    };
    /**
        * @typedef LookAtEvents
        * @intdocs
        * @prop LookAtAchieved `onLookAtAchieved`
        * @prop TrackEntityLost `onTrackEntityLost`
        */
    export const LookAtEvents: {
            LookAtAchieved: JIBO.v1.LookAtEvents.LookAtAchieved;
            TrackEntityLost: JIBO.v1.LookAtEvents.TrackEntityLost;
    };
    /**
        * Enum of speech events.
        * @intdocs
        * @typedef HotWordEvents
        * @prop HotWordHeard `onHotWordHeard`
        * @prop ListenResult `onListenResult`
        */
    export const HotWordEvents: {
            HotWordHeard: JIBO.v1.HotWordEvents.HotWordHeard;
            ListenResult: JIBO.v1.HotWordEvents.ListenResult;
    };
    /**
        * @typedef StreamTypes
        * @intdocs
        * @description Enum of stream types.
        * @prop Entity
        * @prop Speech
        * @prop HeadTouch
        * @prop Motion
        * @prop ScreenGesture
        */
    export const StreamTypes: {
            Entity: JIBO.v1.Streams.Entity;
            HotWord: JIBO.v1.Streams.HotWord;
            HeadTouch: JIBO.v1.Streams.HeadTouch;
            Motion: JIBO.v1.Streams.Motion;
            ScreenGesture: JIBO.v1.Streams.ScreenGesture;
    };
    /**
        * @typedef ListenEvents
        * @intdocs
        * @description Enum of listen events.
        * @prop ListenResult `onListenResult`
        */
    export const ListenEvents: {
            ListenResult: JIBO.v1.ListenEvents.ListenResult;
    };
    /**
        * @typedef ListenStopReasons
        * @intdocs
        * @description Enum of unsuccessful listen stop reasons.
        * @prop NoInput `NoInput`
        * @prop NoMatch `NoMatch`
        * @prop Interrupted `Interrupted`
        */
    export const ListenStopReasons: {
            NoInput: JIBO.v1.ListenStopReasons.NoInput;
            NoMatch: JIBO.v1.ListenStopReasons.NoMatch;
            Interrupted: JIBO.v1.ListenStopReasons.Interrupted;
    };
    /**
        * Enum of entity track events.
        * @intdocs
        * @typedef EntityTrackEvents
        * @prop TrackUpdate `onEntityUpdate`
        * @prop TrackLost `onEntityLost`
        * @prop TrackGained `onEntityGained`
        */
    export const EntityTrackEvents: {
            TrackUpdate: JIBO.v1.EntityTrackEvents.TrackUpdate;
            TrackLost: JIBO.v1.EntityTrackEvents.TrackLost;
            TrackGained: JIBO.v1.EntityTrackEvents.TrackGained;
    };
    /**
        * Enum of motion track events.
        * @intdocs
        * @typedef MotionEvents
        * @prop MotionDetected `onMotionDetected`
        */
    export const MotionEvents: {
            MotionDetected: JIBO.v1.MotionEvents.MotionDetected;
    };
    /**
        * Enum of headtouch events.
        * @intdocs
        * @typedef HeadTouchEvents
        * @prop HeadTouched `onHeadTouch`
        */
    export const HeadTouchEvents: {
            HeadTouched: JIBO.v1.HeadTouchEvents.HeadTouched;
    };
    /**
        * Enum of screen gesture events.
        * @intdocs
        * @typedef ScreenGestureEvents
        * @prop Tap `onTap`
        * @prop Swipe `onSwipe`
        */
    export const ScreenGestureEvents: {
            Tap: JIBO.v1.ScreenGestureEvents.Tap;
            Swipe: JIBO.v1.ScreenGestureEvents.Swipe;
    };
    /**
        * Enum of config events.
        * @intdocs
        * @typedef ConfigEvents
        * @prop onConfig `onConfig`
        */
    export const ConfigEvents: {
            onConfig: JIBO.v1.ConfigEvents.onConfig;
    };
    /**
        * Enum of asset events.
        * @intdocs
        * @typedef FetchAssetEvents
        * @prop AssetReady `onAssetReady`
        * @prop AssetFailed `onAssetFailed`
        */
    export const FetchAssetEvents: {
            AssetReady: JIBO.v1.FetchAssetEvents.AssetReady;
            AssetFailed: JIBO.v1.FetchAssetEvents.AssetFailed;
    };
    /**
        * Enum of unload asset events.
        * @intdocs
        * @typedef UnloadAssetEvents
        * @prop UnloadAssetFailed `onUnloadAssetFailed`
        * @prop UnloadAssetDone `onUnloadAssetDone`
        */
    export const UnloadAssetEvents: {
            UnloadAssetDone: JIBO.v1.UnloadAssetEvents.UnloadAssetDone;
            UnloadAssetFailed: JIBO.v1.UnloadAssetEvents.UnloadAssetFailed;
    };
    /**
        * @typedef CameraResolution
        * @description Enum of camera resolutions
        * @prop HighRes Currently unsupported
        * @prop MedRes Higher res than default
        * @prop LowRes Default
        * @prop MicroRes Lower res than default
        */
    export const CameraResolution: {
            HighRes: JIBO.v1.CameraResolutions.HighRes;
            MedRes: JIBO.v1.CameraResolutions.MedRes;
            LowRes: JIBO.v1.CameraResolutions.LowRes;
            MicroRes: JIBO.v1.CameraResolutions.MicroRes;
    };
    /**
        * Enum of available swipe directions.
        * @typedef SwipeDirection
        * @prop Up
        * @prop Down
        * @prop Right
        * @prop Left
        */
    export const SwipeDirection: {
            Up: JIBO.v1.SwipeDirections.Up;
            Down: JIBO.v1.SwipeDirections.Down;
            Right: JIBO.v1.SwipeDirections.Right;
            Left: JIBO.v1.SwipeDirections.Left;
    };
    /**
        * Camera options.
        * @typedef Camera
        * @prop left Default
        * @prop right Currently unsupported
        */
    export const Camera: {
            Left: JIBO.v1.Cameras.Left;
            Right: JIBO.v1.Cameras.Right;
    };
    /**
        * Enum of entity (face) types.
        * @typedef EntityType
        * @prop person Face is a loop member.
        * @prop unknown Face is not a loop member.
        */
    export const EntityType: {
            Person: JIBO.v1.Entities.Person;
            Unknown: JIBO.v1.Entities.Unknown;
    };
    /**
        * @typedef DisplayErrorDetails
        * @intdocs
        * @prop IdNotUnique View id is not unique
        * @prop MissingValues View was not given required values
        * @prop InvalidViewType View type is not valid
        * @prop AssetError Unable to access assets for display
        */
    export const DisplayErrorDetails: JIBO.v1.DisplayErrorDetails;
    /**
        * @typedef DisplayChangeType
        * @description Enum of ways to change display
        * @prop Swap Swap the current view for another
        */
    export const DisplayChangeType: {
            Swap: JIBO.v1.DisplayChanges.Swap;
    };
    /**
        * @typedef FetchAssetErrorDetails
        * @intdocs
        * @prop OutOfMemory {string} [Response Code]{@link ResponseCode}
        *       406 (NotAcceptable) - Out of memory
        * @prop InvalidURI {string} [Response Code]{@link ResponseCode}
        *       406 (NotAcceptable) - Invalid or Inaccessible URI
        */
    export const FetchAssetErrorDetails: JIBO.v1.FetchAssetErrorDetails;
    /**
        * @typedef UnloadAssetErrorDetails
        * @intdocs
        * @prop InvalidName {string}
        *       406 (NotAcceptable) - Invalid or Inaccessible Name
        */
    export const UnloadAssetErrorDetails: JIBO.v1.UnloadAssetErrorDetails;
    /**
        * @typedef ResponseCode
        * @description Enum of response codes
        * @prop OK `200` - The command was accepted and executed. Synchronous calls only.
        * @prop Created `201` - The command was accepted and executed. Synchronous calls only.
        * @prop Accepted `202` - The command was accepted and will begin execution. Most asynchronous commands will get a this response.
        * @prop BadRequest `400` - Badly formatted request.
        * @prop Forbidden `403` - The command request is not a supported command.
        * @prop NotFound `404` - Command not found.
        * @prop NotAcceptable `406` - The data in the command is not acceptable.
        * @prop RequestTimeout `407 - Unable to marshal the resources and set up the command within the time limits set in the Controller.
        * @prop Conflict `409` - There is a conflicting command already executing
        * @prop PreconditionFailed `412` - The execution of the command requires the execution of a prior command.
        * @prop InternalError `500` - The Controller has crashed or hit a different error that was unexpected.
        * @prop ServiceUnavailable `503` - The Controller is temporarily unavailable. The Robot SSM may be rebooting something.
        * @prop VersionNotSupported `505` - The Version requested is not supported.
        * @prop VersionConflict `506` - The Version requested is not the same version of the current connection.
        */
    export const ResponseCode: {
            OK: JIBO.v1.ResponseCodes.OK;
            Created: JIBO.v1.ResponseCodes.Created;
            Accepted: JIBO.v1.ResponseCodes.Accepted;
            BadRequest: JIBO.v1.ResponseCodes.BadRequest;
            Forbidden: JIBO.v1.ResponseCodes.Forbidden;
            NotFound: JIBO.v1.ResponseCodes.NotFound;
            NotAcceptable: JIBO.v1.ResponseCodes.NotAcceptable;
            RequestTimeout: JIBO.v1.ResponseCodes.RequestTimeout;
            Conflict: JIBO.v1.ResponseCodes.Conflict;
            PreconditionFailed: JIBO.v1.ResponseCodes.PreconditionFailed;
            InternalError: JIBO.v1.ResponseCodes.InternalError;
            ServiceUnavailable: JIBO.v1.ResponseCodes.ServiceUnavailable;
            VersionNotSupported: JIBO.v1.ResponseCodes.VersionNotSupported;
            VersionConflict: JIBO.v1.ResponseCodes.VersionConflict;
    };
    /**
        * @typedef VideoType
        * @description Enum of video types
        * @prop Normal `NORMAL` Default
        * @prop Debug `DEBUG` Currently unsupported.
        */
    export const VideoType: {
            Normal: JIBO.v1.Videos.Normal;
            Debug: JIBO.v1.Videos.Debug;
    };
    /**
        * @typedef ProtocolVersions
        * @description Two of everything! `JIBO.ProtocolVersions` lives in Phoenix repos.
        * @prop v1 {JIBO.ProtocolVersions.v1} `1.0`
        * @prop v2 {JIBO.ProtocolVersions.v2} `2.0`
        */
    export const ProtocolVersions: {
            v1: JIBO.ProtocolVersions.v1;
            v2: JIBO.ProtocolVersions.v2;
    };
}

declare module 'roboconnection/connection/jibo-command-protocol/TypeGuards' {
    export function isEvent(message: JIBO.v1.Acknowledgement | JIBO.v1.EventMessage): message is JIBO.v1.EventMessage;
    export function isAcknowledgement(message: JIBO.v1.Acknowledgement | JIBO.v1.EventMessage): message is JIBO.v1.Acknowledgement;
    export function isAngleTarget(target: JIBO.v1.LookAtTarget): target is JIBO.v1.AngleTarget;
    export function isEntityTarget(target: JIBO.v1.LookAtTarget): target is JIBO.v1.EntityTarget;
    export function isPositionTarget(target: JIBO.v1.LookAtTarget): target is JIBO.v1.PositionTarget;
    export function isCameraTarget(target: JIBO.v1.LookAtTarget): target is JIBO.v1.CameraTarget;
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/LoadAssets' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    /**
        * @class FetchAssetToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class FetchAssetToken extends RequestToken<JIBO.v1.FetchAssetRequest, JIBO.v1.FetchAssetEvent> {
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.FetchAssetRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls Jibo's Load asset management.
        * @namespace Requester.loadAssets
        */
    export class LoadAssets extends RequestAPI<JIBO.v1.FetchAssetRequest, FetchAssetToken> {
            /**
                * Generate loadAsset Protocol
                * @method Requester.loadAssets#generateProtocol
                * @param {string} uri - URI of the asset to be fetched.
                * @param {string} name - Name given to the asset for later reference (must be unique).
                * @returns {FetchAssetRequest}
                * @intdocs
                */
            static generateProtocol(uri: string, name: string): JIBO.v1.FetchAssetRequest;
            /**
                * Command to retrieve external asset and store in local cache by name.
                * @method Requester.loadAssets#fetchAsset
                * @param  {string}   uri Uri where the asset to fetch is.
                * @param  {string}   name Name that the asset will be call by.
                * @return {FetchAssetToken}
                */
            fetchAsset(uri: string, name: string): FetchAssetToken;
            /**
                * @method Requester.loadAssets#generateToken
                * @description Create FetchAssetToken from FetchAssetRequest protocol.
                * @param {FetchAssetRequest} protocol - FetchAssetRequest protocol to generate a FetchAssetToken from.
                * @param {boolean} [andSend=false] - `True` if the generated FetchAssetToken should also be sent as a request.
                * @return {FetchAssetToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.FetchAssetRequest, andSend?: boolean): FetchAssetToken;
            /**
                * Send FetchAssetToken request.
                * <p>NOTE: Implementation in base class {@link RequestAPI}</p>
                * @method Requester.loadAssets#sendToken
                * @param {FetchAssetToken} token - FetchAssetToken to send.
                * @intdocs
                */
            sendToken(token: FetchAssetToken): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/UnloadAssets' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    /**
        * @class UnloadAssetToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class UnloadAssetToken extends RequestToken<JIBO.v1.UnloadAssetRequest, JIBO.v1.UnloadAssetEvent> {
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.UnloadAssetRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls Jibo's asset management.
        * @namespace Requester.unloadAssets
        */
    export class UnloadAssets extends RequestAPI<JIBO.v1.UnloadAssetRequest, UnloadAssetToken> {
            /**
                * Generate Unload Asset Protocol
                * @method Requester.unloadAssets#generateProtocol
                * @param {string} name - Name given to the asset for later reference (must be unique).
                * @returns {UnloadAssetRequest}
                * @intdocs
                */
            static generateProtocol(name: string): JIBO.v1.UnloadAssetRequest;
            /**
                * Command unload asset by name.
                * @method Requester.unloadAssets#unloadAsset
                * @param  {string}   name Name of asset to unload.
                * @return {UnloadAssetToken}
                */
            unloadAsset(name: string): UnloadAssetToken;
            /**
                * @method Requester.unloadAssets#generateUnloadToken
                * @description Create UnloadAssetToken from UnloadAssetRequest protocol.
                * @param {UnloadAssetRequest} protocol - UnloadAssetRequest protocol to generate a UnloadAssetToken from.
                * @param {boolean} [andSend=false] - `True` if the generated UnloadAssetToken should also be sent as a request.
                * @return {UnloadAssetToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.UnloadAssetRequest, andSend?: boolean): UnloadAssetToken;
            /**
                * Send UnloadAssetToken request.
                * @method Requester.unloadAssets#sendToken
                * @param {UnloadAssetToken} token - UnloadAssetToken to send.
                * @intdocs
                */
            sendToken(token: UnloadAssetToken): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/Session' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    /**
        * @class SessionToken
        * @description Response token for the {@link Session} class.
        * @extends RequestToken
        * @hideconstructor
        */
    export class SessionToken extends RequestToken<JIBO.v1.SessionRequest, JIBO.v1.SessionResponse> {
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.SessionRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * @namespace Requester.session
        */
    export class Session extends RequestAPI<JIBO.v1.SessionRequest, SessionToken> {
            /**
                * Generate Session Protocol
                * @method Requester.session#generateProtocol
                * @returns {SessionRequest}
                * @intdocs
                */
            static generateProtocol(): JIBO.v1.SessionRequest;
            /**
                * Start the session.
                * @method Requester.session#startSession
                * @return {SessionToken}
                */
            startSession(): SessionToken;
            /**
                * @method Requester.session#generateToken
                * @description Create SessionToken from SessionRequest protocol.
                * @param {SessionRequest} protocol - SessionRequest protocol to generate a SessionToken from.
                * @param {boolean} [andSend=false] - `True` if the generated SessionToken should also be sent as a request.
                * @return {SessionToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.SessionRequest, andSend?: boolean): SessionToken;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/camera' {
    import * as photo from 'roboconnection/connection/jibo-command-requester/requests/v1/camera/Photo';
    import * as video from 'roboconnection/connection/jibo-command-requester/requests/v1/camera/Video';
    export { photo, video };
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/expression' {
    import * as attention from 'roboconnection/connection/jibo-command-requester/requests/v1/expression/Attention';
    import * as lookAt from 'roboconnection/connection/jibo-command-requester/requests/v1/expression/LookAt';
    import * as display from 'roboconnection/connection/jibo-command-requester/requests/v1/expression/Display';
    import * as play from 'roboconnection/connection/jibo-command-requester/requests/v1/expression/Play';
    import * as video from 'roboconnection/connection/jibo-command-requester/requests/v1/expression/VideoPlayback';
    export { attention, lookAt, display, play, video };
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/listen' {
    import * as hotWord from 'roboconnection/connection/jibo-command-requester/requests/v1/listen/HotWord';
    import * as listen from 'roboconnection/connection/jibo-command-requester/requests/v1/listen/Listen';
    export { hotWord, listen };
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/lps' {
    import * as face from 'roboconnection/connection/jibo-command-requester/requests/v1/lps/FaceTrack';
    import * as motion from 'roboconnection/connection/jibo-command-requester/requests/v1/lps/MotionTrack';
    export { face, motion };
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/sensory' {
    import * as headTouch from 'roboconnection/connection/jibo-command-requester/requests/v1/sensory/HeadTouch';
    import * as screenGesture from 'roboconnection/connection/jibo-command-requester/requests/v1/sensory/ScreenGesture';
    export { headTouch, screenGesture };
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/settings' {
    import * as getConfig from 'roboconnection/connection/jibo-command-requester/requests/v1/settings/GetConfig';
    import * as setConfig from 'roboconnection/connection/jibo-command-requester/requests/v1/settings/SetConfig';
    export { getConfig, setConfig };
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v2/structural' {
    /**
      * @namespace Requester.v2.structural
      * @intdocs
      */
    export * from 'roboconnection/connection/jibo-command-requester/requests/v2/structural/Parallel';
    export * from 'roboconnection/connection/jibo-command-requester/requests/v2/structural/Sequence';
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v2/emotion' {
    /**
      * @namespace Requester.v2.emotion
      * @intdocs
      */
    export * from 'roboconnection/connection/jibo-command-requester/requests/v2/emotion/ImpactEmotion';
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v2/perception' {
    /**
      * @namespace Requester.v2.perception
      * @intdocs
      */
    export * from 'roboconnection/connection/jibo-command-requester/requests/v2/perception/SetPresentPerson';
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v2/Play' {
    /**
        * @namespace Requester.v2.play
        * @intdocs
        */
    export class Play {
            /**
                * Generates Play Protocol. See [Phoenix RCP](https://github.jibo.com/phoenix/jibo-command-protocol) for `JIBO` docs.
                * @method Requester.v2.play#generateProtocol
                * @param {string} esml - ESML string to be spoken.
                * @param {(string|Object)} [config] - AutoRule configuration options for the Play request.
                * @param {Object} [options] - Speak options for the Play request.
                * @returns {JIBO.v2.behaviors.Play}
                */
            static generateProtocol(esml: string, config?: string | Object, options?: Object): JIBO.v2.behaviors.Play;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v2/Listen' {
    /**
        * @namespace Requester.v2.listen
        * @intdocs
        */
    export class Listen {
            /**
                * Generates Listen Protocol. See [Phoenix RCP](https://github.jibo.com/phoenix/jibo-command-protocol) for `JIBO` docs.
                * @method Requester.v2.listen#generateProtocol
                * @param {(string|string[])} ruleContext - Robust Parser Rules / Dialog Flow Agents we're listening for.
                * @param {JIBO.v2.behaviors.Intent[]} intents - Dialog Flow intents
                * @returns {JIBO.v2.behaviors.Listen}
                */
            static generateProtocol(rules: string | string[], intents?: JIBO.v2.behaviors.Intent[]): JIBO.v2.behaviors.Listen;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v2/Display' {
    /**
        * @namespace Requester.v2.display
        * @intdocs
        */
    export class Display {
            /**
                * Generates Display Protocol. See [Phoenix RCP](https://github.jibo.com/phoenix/jibo-command-protocol) for `JIBO` docs.
                * @method Requester.v2.display#generateProtocol
                * @param {string} name - Unique name of the Display.
                * @param {(JIBO.v2.behaviors.EyeDisplay | JIBO.v2.behaviors.NoneDisplay | JIBO.v2.behaviors.MenuDisplay | JIBO.v2.behaviors.Image | JIBO.v2.behaviors.PhotoGallery | JIBO.v2.behaviors.LoopMembersMenu | JIBO.v2.behaviors.SkillDisplay | JIBO.v2.behaviors.TextDisplay)} view - The view to be displayed.
                * @param {(0 | 1 | 2 | 3 | 4)} layer - Which layer the Display will be active on.
                * @param {boolean} visible - If `visible` is `false`, the display will not show until a ShowDisplayAction is called on it.
                * @param {boolean} keepDisplay - If `keepDisplay` is `true`, the display will stay upon completion until removed (?)
                * @param {JIBO.v2.behaviors.Action[]} onCancel - Action handlers for when the Display is cancelled.
                * @param {("dim" | "clear")} [overlay] - Overlay options for the Display.
                * @returns {JIBO.v2.behaviors.Display}
                */
            static generateProtocol(name: string, view: JIBO.v2.behaviors.EyeDisplay | JIBO.v2.behaviors.NoneDisplay | JIBO.v2.behaviors.MenuDisplay | JIBO.v2.behaviors.Image | JIBO.v2.behaviors.PhotoGallery | JIBO.v2.behaviors.LoopMembersMenu | JIBO.v2.behaviors.SkillDisplay | JIBO.v2.behaviors.TextDisplay, layer: 0 | 1 | 2 | 3 | 4, visible: boolean, keepDisplay: boolean, onCancel: JIBO.v2.behaviors.Action[], overlay?: "dim" | "clear"): JIBO.v2.behaviors.Display;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v2/SLIM' {
    /**
        * @namespace Requester.v2.slim
        * @intdocs
        */
    export class SLIM {
            /**
                * Generates SLIM Protocol. See [Phoenix RCP](https://github.jibo.com/phoenix/jibo-command-protocol) for `JIBO` docs.
                * @method Requester.v2.slim#generateProtocol
                * @param {JIBO.v2.behaviors.SLIMConfig} config - What components will comprise the SLIM.
                * @param {JIBO.v2.behaviors.SLIMOptions} [options] - Configuration options for the SLIM.
                * @returns {JIBO.v2.behaviors.SLIM}
                */
            static generateProtocol(config: JIBO.v2.behaviors.SLIMConfig, options?: JIBO.v2.behaviors.SLIMOptions): JIBO.v2.behaviors.SLIM;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/RequestAPI' {
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    export default abstract class RequestAPI<R extends JIBO.v1.BaseCommand, T extends RequestToken<R>> {
        protected owner: Requester;
        constructor(owner: Requester);
        abstract generateToken(protocol: R): T;
        sendToken(token: T): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/camera/Photo' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    /**
        * Reponse token for {@link Photo#takePhoto}.
        * @class PhotoToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class PhotoToken extends RequestToken<JIBO.v1.TakePhotoRequest, JIBO.v1.TakePhotoEvent> {
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.TakePhotoRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls Jibo's photo capture.
        * @namespace Requester.photo
        */
    export class Photo extends RequestAPI<JIBO.v1.TakePhotoRequest, PhotoToken> {
            /**
                * Generate Photo Protocol
                * @method Requester.photo#generateProtocol
                * @param {Camera} [camera=left] - Which camera to use -- left or right.
                * @param {CameraResolution} [resolution=LowRes] - Choose a resolution.
                * @param {boolean} [removeDistortion=true] - Use `false` for fisheye lense.
                * @returns {TakePhotoRequest}
                * @intdocs
                */
            static generateProtocol(camera?: JIBO.v1.Cameras.CameraType, resolution?: JIBO.v1.CameraResolutions.CameraResolutionType, removeDistortion?: boolean): JIBO.v1.TakePhotoRequest;
            /**
                * Take a photo.
                * @method Requester.photo#takePhoto
                * @param  {CameraResolution} [resolution=LowRes] Choose a resolution.
                * @param  {string}           [camera=left] Which camera to use -- left or right.
                * @param  {boolean}          [removeDistortion=true] Use `false` for fisheye lense.
                * @return {PhotoToken}
                */
            takePhoto(resolution?: JIBO.v1.CameraResolutions.CameraResolutionType, camera?: JIBO.v1.Cameras.CameraType, removeDistortion?: boolean): PhotoToken;
            /**
                * @method Requester.photo#generateToken
                * @description Create PhotoToken from TakePhotoRequest protocol.
                * @param {TakePhotoRequest} protocol - TakePhotoRequest protocol to generate a PhotoToken from.
                * @param {boolean} [andSend=false] - `True` if the generated PhotoToken should also be sent as a request.
                * @return {PhotoToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.TakePhotoRequest, andSend?: boolean): PhotoToken;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/camera/Video' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    import { Event } from 'roboconnection/connection/jibo-command-requester/events/Event';
    /**
        * Reponse token for {@link Video#getVideo}.
        * @class VideoToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class VideoToken extends RequestToken<JIBO.v1.VideoRequest, any> {
            /**
                * URL for video stream is ready.
                * @name VideoToken#streamReady
                * @type {Event<string>}
                */
            streamReady: Event<string>;
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.VideoRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls Jibo's video capture.
        * @namespace Requester.video
        */
    export class Video extends RequestAPI<JIBO.v1.VideoRequest, VideoToken> {
            /**
                * Generate Video Protocol
                * @method Requester.video#generateProtocol
                * @param {VideoType} [type=VideoType.Normal] - Choose a video type from the enum.
                * @param {number} [duration=0] - How long to record for (in ms).
                * @returns {VideoRequest}
                * @intdocs
                */
            static generateProtocol(type?: JIBO.v1.Videos.VideoType, duration?: number): JIBO.v1.VideoRequest;
            /**
                * Take a video.
                * @method Requester.video#getVideo
                * @param  {VideoType} [type=Normal] Choose a video type from the enum.
                * @param  {number}    [duration=0] How long to record for (in ms).
                * @return {VideoToken}
                */
            getVideo(type?: JIBO.v1.Videos.VideoType, duration?: number): VideoToken;
            /**
                * @method Requester.video#generateToken
                * @description Create VideoToken from VideoRequest protocol.
                * @param {VideoRequest} protocol - VideoRequest protocol to generate a VideoToken from.
                * @param {boolean} [andSend=false] - `True` if the generated VideoToken should also be sent as a request.
                * @return {VideoToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.VideoRequest, andSend?: boolean): VideoToken;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/expression/Attention' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    /**
        * Response token for the {@link Attention} class.
        * @class AttentionToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class AttentionToken extends RequestToken<JIBO.v1.AttentionRequest, void> {
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.AttentionRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls the Jibo's attention mode.
        * @namespace Requester.attention
        */
    export class Attention extends RequestAPI<JIBO.v1.AttentionRequest, AttentionToken> {
            /**
                * Generate Attention Protocol
                * @method Requester.attention#generateProtocol
                * @param {AttentionMode} mode - Mode to set Jibo's attention to.
                * @returns {AttentionRequest}
                * @intdocs
                */
            static generateProtocol(mode: JIBO.v1.AttentionModes.AttentionModeType): JIBO.v1.AttentionRequest;
            /**
                * Set Jibo's attention to a specific mode.
                * @method Requester.attention#setMode
                * @param  {AttentionMode}  mode Mode to set Jibo's attention to.
                * @return {AttentionToken}
                */
            setMode(mode: JIBO.v1.AttentionModes.AttentionModeType): AttentionToken;
            /**
                * @method Requester.attention#generateToken
                * @description Create AttentionToken from AttentionRequest protocol.
                * @param {AttentionRequest} protocol - AttentionRequest protocol to generate a AttentionToken from.
                * @param {boolean} [andSend=false] - `True` if the generated AttentionToken should also be sent as a request.
                * @return {AttentionToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.AttentionRequest, andSend?: boolean): AttentionToken;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/expression/LookAt' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    export interface LookAtAchievedResult {
            AngleTarget: JIBO.v1.AngleVector;
            PositionTarget: JIBO.v1.Vector3;
    }
    export interface LookAtTrackLostResult {
            EntityTarget: JIBO.v1.LookAtEntity;
            AngleTarget: JIBO.v1.AngleVector;
            PositionTarget: JIBO.v1.Vector3;
    }
    /**
        * Target options for LookAt
        * @typedef TargetMode
        * @prop Positoin
        * @prop Angle
        * @prop Entity
        * @prop Scren
        * @intdocs
        */
    export enum TargetMode {
            Position = 0,
            Angle = 1,
            Entity = 2,
            Screen = 3
    }
    /**
        * Reponse token for {@link LookAt} APIs.
        * @class LookAtToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class LookAtToken extends RequestToken<JIBO.v1.LookAtRequest, LookAtAchievedResult | LookAtTrackLostResult> {
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.LookAtRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls Jibo's LookAt movement.
        * @namespace Requester.lookAt
        */
    export class LookAt extends RequestAPI<JIBO.v1.LookAtRequest, LookAtToken> {
            /**
                * Generate LookAt Protocol
                * @method Requester.lookAt#generateProtocol
                * @param {TargetMode} targetMode - How we are targetting our target (depends on the target type)
                * @param {(Vector2|Vector3|LookAtEntity)} target - What we're looking at (Entity, Angle or Point in space)
                * @param {boolean} levelHead - `true` to keep Jibo's head level while he moves.
                * @param {boolean} [shouldTrack=false] - If we should track the target entity (Entity-Mode only)
                * @returns {LookAtRequest}
                * @intdocs
                */
            static generateProtocol(targetMode: TargetMode, target: JIBO.v1.Vector2 | JIBO.v1.Vector3 | JIBO.v1.LookAtEntity, levelHead: boolean, shouldTrack?: boolean): JIBO.v1.LookAtRequest;
            /**
                * @method Requester.lookAt#position
                * @description Look toward a 3D point in space.
                * @param  {Vector3}     target 3D point to look at (`[x, y, z]`).
                * @param  {boolean}     [levelHead=true] `true` to keep Jibo's head level while he moves.
                * @return {LookAtToken}
                */
            position(target: JIBO.v1.Vector3, levelHead?: boolean): LookAtToken;
            /**
                * @method Requester.lookAt#angle
                * @description Look at an angle.
                * @param  {AngleVector}    target Angle to look at (`[theta, psi]`).
                * @param  {boolean}        [levelHead=true] `true` to keep Jibo's head level while he moves.
                * @return {LookAtToken}
                */
            angle(target: JIBO.v1.AngleVector, levelHead?: boolean): LookAtToken;
            /**
                * @method Requester.lookAt#screenPosition
                * @description Look at a point relative to Jibo's screen.
                * @param  {Vector2}     target Point to look at (`[x, y, width, height]`).
                * @param  {boolean}     [levelHead=true] `true` to keep Jibo's head level while he moves.
                * @return {LookAtToken}
                */
            screenPosition(target: JIBO.v1.Vector2, levelHead?: boolean): LookAtToken;
            /**
                * @method Requester.lookAt#entity
                * @description Look at an entity (usually a face).
                * @param  {LookAtEntity}   target Entity to look at.
                * @param  {boolean}        [levelHead=true] `true` to keep Jibo's head level while he moves.
                * @return {LookAtToken}
                */
            entity(target: JIBO.v1.LookAtEntity, shouldTrack: boolean, levelHead?: boolean): LookAtToken;
            /**
                * @method Requester.lookAt#generateToken
                * @description Create LookAtToken from LookAtRequest protocol.
                * @param {LookAtRequest} protocol - LookAtRequest protocol to generate a LookAtToken from.
                * @param {boolean} [andSend=false] - `True` if the generated LookAtToken should also be sent as a request.
                * @return {LookAtToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.LookAtRequest, andSend?: boolean): LookAtToken;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/expression/Display' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    import { Event } from 'roboconnection/connection/jibo-command-requester/events/Event';
    /**
        * Reponse token for {@link Display} APIs.
        * @class DisplayToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class DisplayToken extends RequestToken<JIBO.v1.DisplayRequest> {
            /**
                * Emitted when a display view is opened.
                * @name DisplayToken#opened
                * @type {Event}
                */
            opened: Event<void>;
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.DisplayRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls which views appear on Jibo's screen.
        * @namespace Requester.display
        */
    export class Display extends RequestAPI<JIBO.v1.DisplayRequest, DisplayToken> {
            /**
                * Generate Display Protocol
                * @method Requester.display#generateProtocol
                * @param {(EyeView | TextView | ImageView)} view - View to replace the existing one with.
                * @returns {DisplayRequest}
                * @intdocs
                */
            static generateProtocol(view: JIBO.v1.EyeView | JIBO.v1.TextView | JIBO.v1.ImageView): JIBO.v1.DisplayRequest;
            swap(view: JIBO.v1.EyeView | JIBO.v1.TextView | JIBO.v1.ImageView): DisplayToken;
            /**
                * @method Requester.display#swapView
                * @description Replace the existing view with the one given.
                * @param  {EyeView | TextView | ImageView}  view View to replace the existing one with.
                * @return {DisplayToken}
                */
            swapView(view: JIBO.v1.EyeView | JIBO.v1.TextView | JIBO.v1.ImageView): DisplayToken;
            /**
                * @method Requester.display#createEyeView
                * @description Create a view to display Jibo's eye on screen.
                * @param  {string} name Unique name of view.
                * @return {EyeView}
                */
            createEyeView(name: string): JIBO.v1.EyeView;
            /**
                * @method Requester.display#createTextView
                * @description Create a view to display text on Jibo's screen.
                * @param  {string} name Unique name of view.
                * @param  {string} text Text to display on screen.
                * @return {TextView}
                */
            createTextView(name: string, text: string): JIBO.v1.TextView;
            /**
                * @method Requester.display#createImageView
                * @description Create a view to display an image on Jibo's screen.
                * @param  {string} name Unique name of view.
                * @param  {ImageData} data Data for retrieving image.
                * @return {ImageView}
                */
            createImageView(name: string, data: JIBO.v1.ImageData): JIBO.v1.ImageView;
            /**
                * @method Requester.display#generateToken
                * @description Create DisplayToken from DisplayRequest protocol.
                * @param {DisplayRequest} protocol - DisplayRequest protocol to generate a DisplayToken from.
                * @param {boolean} [andSend=false] - `True` if the generated DisplayToken should also be sent as a request.
                * @return {DisplayToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.DisplayRequest, andSend?: boolean): DisplayToken;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/expression/Play' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    /**
        * @class SayToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class SayToken extends RequestToken<JIBO.v1.SayRequest> {
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.SayRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls Jibo's speech and audio.
        * @namespace Requester.play
        */
    export class Play extends RequestAPI<JIBO.v1.SayRequest, SayToken> {
            /**
                * Generate Play Protocol
                * @method Requester.play#generateProtocol
                * @param {string} esml_uri - ESML to speak or URI of sound to play
                * @param {JIBO.v1.SpeakOptions} [speakOptions] Options to configure , can be used in conjunction with ESML strings.
                * @param {JIBO.v1.AutoRuleConfig} [autoRuleConfig] Configuration for AutoRules , can be used in conjunction with ESML strings.
                * @returns {SayRequest}
                * @intdocs
                */
            static generateProtocol(esmlUri: string, speakOptions?: JIBO.v1.SpeakOptions, autoRuleConfig?: JIBO.v1.AutoRuleConfig): JIBO.v1.SayRequest;
            /**
                * Make Jibo speak.
                * @method Requester.play#say
                * @param  {string}   esml Embodied Speech Markup Language to say. See the [ESML Documentation]{@tutorial esml}.
                * @param {JIBO.v1.SpeakOptions} [speakOptions] Options to configure , can be used in conjunction with ESML strings.
                * @param {JIBO.v1.AutoRuleConfig} [autoRuleConfig] Configuration for AutoRules , can be used in conjunction with ESML strings.
                * @return {SayToken}
                */
            say(esml: string, speakOptions?: JIBO.v1.SpeakOptions, autoRuleConfig?: JIBO.v1.AutoRuleConfig): SayToken;
            /**
                * Make Jibo play a sound.
                * @method Requester.play#sound
                * @param  {string}   uri URI to the sound to play.
                * @return {SayToken}
                */
            sound(uri: string): SayToken;
            /**
                * @method Requester.play#generateToken
                * @description Create SayToken from SayRequest protocol.
                * @param {SayRequest} protocol - SayRequest protocol to generate a SayToken from.
                * @param {boolean} [andSend=false] - `True` if the generated SayToken should also be sent as a request.
                * @return {SayToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.SayRequest, andSend?: boolean): SayToken;
            /**
                * Send SayToken request.
                * <p>NOTE: Implementation in base class {@link RequestAPI}</p>
                * @method Requester.play#sendToken
                * @param {SayToken} token - SayToken to send.
                * @intdocs
                */
            sendToken(token: SayToken): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/expression/VideoPlayback' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    /**
        * Response token for the {@link VideoPlayback} class.
        * @class AttentionToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class VideoPlaybackToken extends RequestToken<JIBO.v1.VideoPlaybackRequest, void> {
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.VideoPlaybackRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls the Jibo's attention mode.
        * @namespace Requester.attention
        */
    export class VideoPlayback extends RequestAPI<JIBO.v1.VideoPlaybackRequest, VideoPlaybackToken> {
            /**
                * Generate Attention Protocol
                * @method Requester.attention#generateProtocol
                * @param {AttentionMode} mode - Mode to set Jibo's attention to.
                * @returns {AttentionRequest}
                * @intdocs
                */
            static generateProtocol(url: string): JIBO.v1.VideoPlaybackRequest;
            /**
                * Set Jibo's attention to a specific mode.
                * @method Requester.attention#setMode
                * @param  {AttentionMode}  mode Mode to set Jibo's attention to.
                * @return {AttentionToken}
                */
            play(url: string): VideoPlaybackToken;
            /**
                * @method Requester.attention#generateToken
                * @description Create AttentionToken from AttentionRequest protocol.
                * @param {AttentionRequest} protocol - AttentionRequest protocol to generate a AttentionToken from.
                * @param {boolean} [andSend=false] - `True` if the generated AttentionToken should also be sent as a request.
                * @return {AttentionToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.VideoPlaybackRequest, andSend?: boolean): VideoPlaybackToken;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/listen/HotWord' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    import { Event } from 'roboconnection/connection/jibo-command-requester/events/Event';
    /**
        * @class HotWordToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class HotWordToken extends RequestToken<JIBO.v1.HotWordRequest> {
            /**
                * Heard "Hey Jibo"
                * @name HotWordToken#hotWordHeard
                * @type {Event}
                */
            hotWordHeard: Event<JIBO.v1.HotWordHeardEvent>;
            /**
                * Result of what Jibo head is available.
                * @name HotWordToken#listenResult
                * @type {Event<string>}
                */
            listenResult: Event<string>;
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.HotWordRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls Jibo's HotWord Listening.
        * CURRENTLY UNSUPPORTED
        * @namespace Requester.hotWord
        */
    export class HotWord extends RequestAPI<JIBO.v1.HotWordRequest, HotWordToken> {
            /**
                * Generate HotWord Protocol
                * @method Requester.hotWord#generateProtocol
                * @param {boolean} [listen=false] - Whether to listen for additional speech input after "Hey Jibo" is heard.
                * @returns {HotWordRequest}
                * @intdocs
                */
            static generateProtocol(listen?: boolean): JIBO.v1.HotWordRequest;
            /**
                * Listen for "Hey Jibo".
                * @method Requester.hotWord#listen
                * @param {boolean} [listen = false] Whether to listen for additional speech input after "Hey Jibo" is heard.
                * @return {HotWordToken}
                */
            listen(listen?: boolean): HotWordToken;
            /**
                * @method Requester.hotWord#generateToken
                * @description Create HotWordToken from HotWordRequest protocol.
                * @param {HotWordRequest} protocol - HotWordRequest protocol to generate a HotWordToken from.
                * @param {boolean} [andSend=false] - `True` if the generated HotWordToken should also be sent as a request.
                * @return {HotWordToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.HotWordRequest, andSend?: boolean): HotWordToken;
            /**
                * Send HotWordToken request.
                * <p>NOTE: Implementation in base class {@link RequestAPI}</p>
                * @method Requester.hotWord#sendToken
                * @param {HotWordToken} token - HotWordToken to send.
                * @intdocs
                */
            sendToken(token: HotWordToken): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/listen/Listen' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import { Event } from 'roboconnection/connection/jibo-command-requester/events/Event';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    /**
        * Request token for the {@link Listen} class.
        * @class ListenToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class ListenToken extends RequestToken<JIBO.v1.ListenRequest, JIBO.v1.ListenResultEvent | JIBO.v1.ListenStopEvent> {
            /**
                * Listen token was updated. See [RCP Docs](https://github.jibo.com/phoenix/jibo-command-protocol) for docs.
                * @name ListenToken#update
                * @type {Event<JIBO.v1.ListenResultEvent>}
                */
            update: Event<JIBO.v1.ListenResultEvent>;
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.ListenRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls Jibo's Listening.
        * @namespace Requester.listen
        */
    export class Listen extends RequestAPI<JIBO.v1.ListenRequest, ListenToken> {
            /**
                * Generate Listen Protocol
                * @method Requester.listen#generateProtocol
                * @param {number} [maxSpeechTimeout=15] - Max speech timeout (in seconds)
                * @param {number} [maxNoSpeechTimeout=15] - Max no speech timeout (in seconds)
                * @param {string} [languageCode='en-US'] - Language code
                * @returns {ListenRequest}
                * @intdocs
                */
            static generateProtocol(maxSpeechTimeout?: number, maxNoSpeechTimeout?: number, languageCode?: string): JIBO.v1.ListenRequest;
            subscribe: {
                    hotword: any;
            };
            start(maxSpeechTimeout?: number, maxNoSpeechTimeout?: number, languageCode?: string): ListenToken;
            /**
                * Request for the robot to listen.
                * @method Requester.listen#listen
                * @param  {number}   [maxSpeechTimeout = 15] In seconds
                * @param  {number}   [maxNoSpeechTimeout = 15] In seconds
                * @param  {number}   [languageCode = en_US]
                * @return {ListenToken}
                */
            listen(maxSpeechTimeout?: number, maxNoSpeechTimeout?: number, languageCode?: string): ListenToken;
            /**
                * @method Requester.listen#generateToken
                * @description Create ListenToken from ListenRequest protocol.
                * @param {ListenRequest} protocol - ListenRequest protocol to generate a ListenToken from.
                * @param {boolean} [andSend=false] - `True` if the generated ListenToken should also be sent as a request.
                * @return {ListenToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.ListenRequest, andSend?: boolean): ListenToken;
            /**
                * Send ListenToken request.
                * <p>NOTE: Implementation in base class {@link RequestAPI}</p>
                * @method Requester.listen#sendToken
                * @param {ListenToken} token - ListenToken to send.
                * @intdocs
                */
            sendToken(token: ListenToken): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/lps/FaceTrack' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    import { Event } from 'roboconnection/connection/jibo-command-requester/events/Event';
    /**
        * Request token for the {@link FaceTrack} class.
        * @class FaceTrackToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class FaceTrackToken extends RequestToken<JIBO.v1.EntityRequest, any> {
            /**
                * Update on location of face being tracked.
                * @name FaceTrackToken#update
                * @type {Event<TrackedEntity[]>}
                */
            update: Event<JIBO.v1.TrackedEntity[]>;
            /**
                * New face being tracked.
                * @name FaceTrackToken#gained
                * @type {Event<TrackedEntity[]>}
                */
            gained: Event<JIBO.v1.TrackedEntity[]>;
            /**
                * Currently tracked face was lost.
                * @name FaceTrackToken#lost
                * @type {Event<TrackedEntity[]>}
                */
            lost: Event<JIBO.v1.TrackedEntity[]>;
            constructor(owner: Requester, protocol: JIBO.v1.EntityRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls Jibo's face tracking.
        * @namespace Requester.faceTrack
        */
    export class FaceTrack extends RequestAPI<JIBO.v1.EntityRequest, FaceTrackToken> {
            /**
                * Generate Face Track Protocol
                * @method Requester.faceTrack#generateProtocol
                * @returns {EntityRequest}
                * @intdocs
                */
            static generateProtocol(): JIBO.v1.EntityRequest;
            /**
                * @method Requester.faceTrack#trackFaces
                * @description Track all faces in Jibo's field of vision.
                * @return {FaceTrackToken}
                */
            trackFaces(): FaceTrackToken;
            /**
                * @method Requester.faceTrack#generateToken
                * @description Create FaceTrackToken from EntityRequest protocol.
                * @param {EntityRequest} protocol - EntityRequest protocol to generate a FaceTrackToken from.
                * @param {boolean} [andSend=false] - `True` if the generated FaceTrackToken should also be sent as a request.
                * @return {FaceTrackToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.EntityRequest, andSend?: boolean): FaceTrackToken;
            /**
                * Send FaceTrackToken request.
                * <p>NOTE: Implementation in base class {@link RequestAPI}</p>
                * @method Requester.faceTrack#sendToken
                * @param {FaceTrackToken} token - FaceTrackToken to send.
                * @intdocs
                */
            sendToken(token: FaceTrackToken): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/lps/MotionTrack' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    import { Event } from 'roboconnection/connection/jibo-command-requester/events/Event';
    /**
        * Request token for the {@link MotionTrack} class.
        * @class MotionToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class MotionToken extends RequestToken<JIBO.v1.MotionRequest, any> {
            /**
                * @name MotionToken#update
                * @type {Event<MotionEntity[]>}
                */
            update: Event<JIBO.v1.MotionEntity[]>;
            constructor(owner: Requester, protocol: JIBO.v1.MotionRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls Jibo's mostion tracking.
        * @namespace Requester.motionTrack
        */
    export class MotionTrack extends RequestAPI<JIBO.v1.MotionRequest, MotionToken> {
            /**
                * Generate Motion Track Protocol
                * @method Requester.motionTrack#generateProtocol
                * @returns {MotionRequest}
                * @intdocs
                */
            static generateProtocol(): JIBO.v1.MotionRequest;
            /**
                * @method Requester.motionTrack#trackMotions
                * @description Track all motions in Jibo's field of vision.
                * @return {MotionToken}
                */
            trackMotions(): MotionToken;
            /**
                * @method Requester.motionTrack#generateToken
                * @description Create MotionToken from MotionRequest protocol.
                * @param {MotionRequest} protocol - MotionRequest protocol to generate a MotionToken from.
                * @param {boolean} [andSend=false] - `True` if the generated MotionToken should also be sent as a request.
                * @return {MotionToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.MotionRequest, andSend?: boolean): MotionToken;
            /**
                * Send MotionToken request.
                * <p>NOTE: Implementation in base class {@link RequestAPI}</p>
                * @method Requester.motionTrack#sendToken
                * @param {MotionToken} token - MotionToken to send.
                * @intdocs
                */
            sendToken(token: MotionToken): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/sensory/HeadTouch' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    import { Event } from 'roboconnection/connection/jibo-command-requester/events/Event';
    /**
        * @class HeadTouchToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class HeadTouchToken extends RequestToken<JIBO.v1.HeadTouchRequest> {
            /**
                * One or more of Jibo's touchpad sensors was touched.
                * @name HeadTouchToken#HeadTouchEvent
                * @type {Event}
                */
            update: Event<boolean[]>;
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.HeadTouchRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls subscription to Head Touch events
        * @namespace Requester.headTouch
        */
    export class HeadTouch extends RequestAPI<JIBO.v1.HeadTouchRequest, HeadTouchToken> {
            /**
                * Generate Head Touch Protocol
                * @method Requester.headTouch#generateProtocol
                * @returns {HeadTouchRequest}
                * @intdocs
                */
            static generateProtocol(): JIBO.v1.HeadTouchRequest;
            /**
                * Listen for head touch.
                * @method Requester.headTouch#listen
                * @return {HeadTouchToken}
                */
            listen(): HeadTouchToken;
            /**
                * @method Requester.headTouch#generateToken
                * @description Create HeadTouchToken from HeadTouchRequest protocol.
                * @param {HeadTouchRequest} protocol - HeadTouchRequest protocol to generate a HeadTouchToken from.
                * @param {boolean} [andSend=false] - `True` if the generated HeadTouchToken should also be sent as a request.
                * @return {HeadTouchToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.HeadTouchRequest, andSend?: boolean): HeadTouchToken;
            /**
                * Send HeadTouchToken request.
                * <p>NOTE: Implementation in base class {@link RequestAPI}</p>
                * @method Requester.headTouch#sendToken
                * @param {HeadTouchToken} token - HeadTouchToken to send.
                * @intdocs
                */
            sendToken(token: HeadTouchToken): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/sensory/ScreenGesture' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    import { Event } from 'roboconnection/connection/jibo-command-requester/events/Event';
    /**
        * Reponse token for {@link ScreenGesture} APIs.
        * @class ScreenGestureToken
        * @extends RequestToken
        * @hideconstructor
        */
    export class ScreenGestureToken extends RequestToken<JIBO.v1.ScreenGestureRequest> {
            /**
                * Tap screen gesture. `[x,y]` of tap location type.
                * @name ScreenGestureToken#tap
                * @type {Event<Vector2>}
                */
            tap: Event<JIBO.v1.Vector2>;
            /**
                * Swipe screen gesture. Type is direction of swipe.
                * @name ScreenGestureToken#swipe
                * @type {Event<SwipeDirection>}
                */
            swipe: Event<JIBO.v1.SwipeDirections.SwipeDirectionType>;
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.ScreenGestureRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Allows subsription to the events emited when a gesture is detected in the Jibo screen.
        * @namespace Requester.screenGesture
        */
    export class ScreenGesture extends RequestAPI<JIBO.v1.ScreenGestureRequest, ScreenGestureToken> {
            /**
                * Generate Screen Gesture Protocol
                * @method Requester.screenGesture#generateProtocol
                * @param {ScreenGestureFilter} [filter={}]
                * @returns {ScreenGestureRequest}
                * @intdocs
                */
            static generateProtocol(filter?: JIBO.v1.ScreenGestureFilter): JIBO.v1.ScreenGestureRequest;
            /**
                * @method Requester.screenGesture#subscribe
                * @description Listen for screen touch input.
                * @param  {ScreenGestureFilter}  filter Data for screen touch info, including type of gesture to listen
                * for and area to listen in.
                * @return {ScreenGestureToken}
                */
            subscribe(filter?: JIBO.v1.ScreenGestureFilter): ScreenGestureToken;
            /**
                * @method Requester.screenGesture#generateToken
                * @description Create ScreenGestureToken from ScreenGestureRequest protocol.
                * @param {ScreenGestureRequest} protocol - ScreenGestureRequest protocol to generate a ScreenGestureToken from.
                * @param {boolean} [andSend=false] - `True` if the generated ScreenGestureToken should also be sent as a request.
                * @return {ScreenGestureToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.ScreenGestureRequest, andSend?: boolean): ScreenGestureToken;
            /**
                * Send ScreenGestureToken request.
                * <p>NOTE: Implementation in base class {@link RequestAPI}</p>
                * @method Requester.screenGesture#sendToken
                * @param {ScreenGestureToken} token - ScreenGestureToken to send.
                * @intdocs
                */
            sendToken(token: ScreenGestureToken): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/settings/GetConfig' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    /**
        * @class GetConfigToken
        * @description Response token for the {@link GetConfig#get} class.
        * @extends RequestToken
        * @hideconstructor
        */
    export class GetConfigToken extends RequestToken<JIBO.v1.GetConfigRequest, JIBO.v1.ConfigEvent> {
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.GetConfigRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls getting robot configuration options
        * @namespace Requester.getConfig
        */
    export class GetConfig extends RequestAPI<JIBO.v1.GetConfigRequest, GetConfigToken> {
            /**
                * Generate Get Config Protocol
                * @method Requester.getConfig#generateProtocol
                * @returns {GetConfigRequest}
                * @intdocs
                */
            static generateProtocol(): JIBO.v1.GetConfigRequest;
            /**
                * Get robot configuration options.
                * @method Requester.getConfig#get
                * @return {GetConfigToken}
                */
            get(): GetConfigToken;
            /**
                * @method Requester.getConfig#generateToken
                * @description Create GetConfigToken from GetConfigRequest protocol.
                * @param {GetConfigRequest} protocol - GetConfigRequest protocol to generate a GetConfigToken from.
                * @param {boolean} [andSend=false] - `True` if the generated GetConfigToken should also be sent as a request.
                * @return {GetConfigToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.GetConfigRequest, andSend?: boolean): GetConfigToken;
            /**
                * Send GetConfigToken request.
                * <p>NOTE: Implementation in base class {@link RequestAPI}</p>
                * @method Requester.getConfig#sendToken
                * @param {GetConfigToken} token - GetConfigToken to send.
                * @intdocs
                */
            sendToken(token: GetConfigToken): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v1/settings/SetConfig' {
    import RequestToken from 'roboconnection/connection/jibo-command-requester/tokens/RequestToken';
    import Requester from 'roboconnection/connection/jibo-command-requester/Requester';
    import RequestAPI from 'roboconnection/connection/jibo-command-requester/requests/RequestAPI';
    /**
        * @class SetConfigToken
        * @description Response token for the {@link SetConfig#set} class.
        * @extends RequestToken
        * @hideconstructor
        */
    export class SetConfigToken extends RequestToken<JIBO.v1.SetConfigRequest> {
            /** @private */
            constructor(owner: Requester, protocol: JIBO.v1.SetConfigRequest);
            /**
                * @private
                */
            handleAck(ack: JIBO.v1.Acknowledgement): void;
            /**
                * @private
                */
            handleEvent(event: JIBO.v1.EventMessage): void;
    }
    /**
        * Controls setting robot configuration options
        * @namespace Requester.setConfig
        */
    export class SetConfig extends RequestAPI<JIBO.v1.SetConfigRequest, SetConfigToken> {
            /**
                * Generate Set Config Protocol
                * @method Requester.setConfig#generateProtocol
                * @param {SetConfigOptions} options
                * @returns {SetConfigRequest}
                * @intdocs
                */
            static generateProtocol(options: JIBO.v1.SetConfigOptions): JIBO.v1.SetConfigRequest;
            /**
                * Set robot configuration options.
                * @method Requester.setConfig#set
                * @param  {number}  mixer Volume between 0 (mute) and 1 (loudest).
                * @return {SetConfigToken}
                */
            set(options: JIBO.v1.SetConfigOptions): SetConfigToken;
            /**
                * @method Requester.setConfig#generateToken
                * @description Create SetConfigToken from SetConfigRequest protocol.
                * @param {SetConfigRequest} protocol - SetConfigRequest protocol to generate a SetConfigToken from.
                * @param {boolean} [andSend=false] - `True` if the generated SetConfigToken should also be sent as a request.
                * @return {SetConfigToken}
                * @intdocs
                */
            generateToken(protocol: JIBO.v1.SetConfigRequest, andSend?: boolean): SetConfigToken;
            /**
                * Send SetConfigToken request.
                * <p>NOTE: Implementation in base class {@link RequestAPI}</p>
                * @method Requester.setConfig#sendToken
                * @param {SetConfigToken} token - SetConfigToken to send.
                * @intdocs
                */
            sendToken(token: SetConfigToken): void;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v2/structural/Parallel' {
    /**
        * @class Requester.v2.structural.Parallel
        * @intdocs
        */
    export class Parallel {
            /**
                * Generates Parallel Protocol. See [Phoenix RCP](https://github.jibo.com/phoenix/jibo-command-protocol) for `JIBO` docs.
                * @method Requester.v2.structural.Parallel#generateProtocol
                * @param {JIBO.v2.behaviors.Behavior[]} behaviors - Behaviors to execute in parallel
                * @param {JIBO.v2.behaviors.Behavior[]} [succeedOnFirst=false] - `true` if the entire behavior should succeed when the child who suceeds first does.
                * @returns {JIBO.v2.behaviors.Parallel}
                */
            static generateProtocol(behaviors: JIBO.v2.behaviors.Behavior[], succeedOnFirst?: boolean): JIBO.v2.behaviors.Parallel;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v2/structural/Sequence' {
    /**
        * @class Requester.v2.structural.Sequence
        * @intdocs
        */
    export class Sequence {
            /**
                * Generates Sequence Protocol. See [Phoenix RCP](https://github.jibo.com/phoenix/jibo-command-protocol) for `JIBO` docs.
                * @method Requester.v2.structural.Sequence#generateProtocol
                * @param {JIBO.v2.behaviors.Behavior[]} behaviors - Behaviors to execute in sequence
                * @returns {JIBO.v2.behaviors.Sequence}
                */
            static generateProtocol(behaviors: JIBO.v2.behaviors.Behavior[]): JIBO.v2.behaviors.Sequence;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v2/emotion/ImpactEmotion' {
    /**
        * @class Requester.v2.emotion.ImpactEmotion
        * @intdocs
        */
    export class ImpactEmotion {
            /**
                * Generates ImpactEmotion Protocol. See [Phoenix RCP](https://github.jibo.com/phoenix/jibo-command-protocol) for `JIBO` docs.
                * @method Requester.v2.emotion.ImpactEmotion#generateProtocol
                * @param {("NONE" | "LOW_POS" | "MEDIUM_POS" | "HIGH_POS" | "LOW_NEG" | "MEDIUM_NEG" | "HIGH_NEG")} [valence] - Impact the valence axis
                * @param {("NONE" | "LOW_POS" | "MEDIUM_POS" | "HIGH_POS" | "LOW_NEG" | "MEDIUM_NEG" | "HIGH_NEG")} [confidence] - Impact the confidence axis
                * @returns {JIBO.v2.behaviors.ImpactEmotion}
                */
            static generateProtocol(valence?: "NONE" | "LOW_POS" | "MEDIUM_POS" | "HIGH_POS" | "LOW_NEG" | "MEDIUM_NEG" | "HIGH_NEG", confidence?: "NONE" | "LOW_POS" | "MEDIUM_POS" | "HIGH_POS" | "LOW_NEG" | "MEDIUM_NEG" | "HIGH_NEG"): JIBO.v2.behaviors.ImpactEmotion;
    }
}

declare module 'roboconnection/connection/jibo-command-requester/requests/v2/perception/SetPresentPerson' {
    /**
        * @class Requester.v2.perception.SetPresentPerson
        * @intdocs
        */
    export class SetPresentPerson {
            /**
                * Generates SetPresentPerson Protocol. See [Phoenix RCP](https://github.jibo.com/phoenix/jibo-command-protocol) for `JIBO` docs.
                * @method Requester.v2.perception.SetPresentPerson#generateProtocol
                * @param {string} looperId - Loop member's ID
                * @param {("VOICE" | "FACE" | "USER_OVERRIDE")} source - Source of the ID
                * @param {number} confidence - Confidence level in this claim of presence
                * @returns {JIBO.v2.behaviors.SetPresentPerson}
                */
            static generateProtocol(looperId: string, source: "VOICE" | "FACE" | "USER_OVERRIDE", confidence: number): JIBO.v2.behaviors.SetPresentPerson;
    }
}

